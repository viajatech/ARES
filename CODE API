#Recuerda darle like al repositorio como forma de agradecimiento; https://github.com/viajatech/ARES/  
#(Hecho por David Ruiz alias @viajatech 

#Agradecimiento especial a Anthropic A.I al otorgar su tecnologia a 1,000 desarrolladores en el mundo y ser uno de los seleccionados



# Dependencias principales
#pip install psutil pyperclip pywin32 selenium webdriver_manager 
#pip install speechrecognition gradio openai yt-dlp requests

# Dependencias multimedia
#pip install pillow pygame python-vlc

# Dependencias API LLM
#pip install anthropic google-generativeai 

# Para Azure TTS (opcional)
#pip install azure-cognitiveservices-speech



# =============================================================================
#  TRON ARES by Viaja Tech (Versión 2.0)
#    - Word, Excel, Notepad, Chrome, Firefox
#    - Descarga videos y música de YouTube y otras plataformas
#    - Reproducción de música y videos descargados
#    - Integración con APIs de Anthropic, OpenAI y Google Gemini
#    - Generación de imágenes y videos
# =============================================================================

import os
import sys
import time
import datetime
import threading
import subprocess
import tempfile
import logging
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, PhotoImage
import json
from io import BytesIO
import re
import glob
import shutil  # Para operaciones de archivos
import uuid
import base64
from PIL import Image, ImageTk

# Dependencias comunes
import psutil
import pyperclip
import pythoncom
import win32com.client as win32

# Selenium para navegadores
import urllib.parse
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.firefox.service import Service as FirefoxService
from webdriver_manager.chrome import ChromeDriverManager
from webdriver_manager.firefox import GeckoDriverManager
import pywintypes

# STT / TTS
import speech_recognition as sr
try:
    import azure.cognitiveservices.speech as speechsdk
    azure_available = True
except ImportError:
    azure_available = False

# Gradio para interfaz de chat
import gradio as gr

# OpenAI -> LM Studio
from openai import OpenAI

# yt-dlp para descarga de videos/música
import yt_dlp

# Reproducción de medios
try:
    import pygame
    pygame_available = True
except ImportError:
    pygame_available = False

try:
    import vlc
    vlc_available = True
except ImportError:
    vlc_available = False

# Dependencias para las APIs de LLM
import requests

try:
    import anthropic
    anthropic_available = True
except ImportError:
    anthropic_available = False

try:
    import google.generativeai as genai
    from google.generativeai.types import HarmCategory, HarmBlockThreshold
    genai_available = True
except ImportError:
    genai_available = False

###############################################################################
#                         LOGGING MEJORADO
###############################################################################
# Configurar logging para mostrar en consola Y archivo
logger = logging.getLogger("TRON_ARES")
logger.setLevel(logging.DEBUG)

# Crear manejador para archivo
file_handler = logging.FileHandler('tron_ares.log', mode='w')
file_handler.setLevel(logging.INFO)
file_format = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
file_handler.setFormatter(file_format)

# Crear manejador para consola
console_handler = logging.StreamHandler(sys.stdout)
console_handler.setLevel(logging.DEBUG)  # Mostrar todo en consola
console_format = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
console_handler.setFormatter(console_format)

# Añadir ambos manejadores al logger
logger.addHandler(file_handler)
logger.addHandler(console_handler)

# Sobrescribir logging estándar para asegurar que todo se muestre
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('tron_ares_basic.log')
    ]
)

###############################################################################
#                      MANEJADORES DE APIS DE LLM
###############################################################################
class LLMProvider:
    """Clase base para todos los proveedores de LLM"""
    def __init__(self, api_key=None):
        self.api_key = api_key
        self.client = None
        self.models = []
        self.max_token_limit = 8192
        self.supports_images = False
        self.supports_videos = False
        self.supports_thinking = False
        
    def initialize(self):
        """Inicializa la conexión con el proveedor"""
        pass
        
    def get_available_models(self):
        """Devuelve la lista de modelos disponibles"""
        return self.models
        
    def generate_response(self, messages, model, temperature, max_tokens, **kwargs):
        """Genera una respuesta usando el modelo especificado"""
        pass
        
    def generate_image(self, prompt, size="1024x1024", **kwargs):
        """Genera una imagen desde un prompt si el proveedor lo soporta"""
        if not self.supports_images:
            return None, "Este proveedor no soporta generación de imágenes"
        return None, "Método no implementado"
        
    def generate_video(self, prompt, duration=5, quality="standard", **kwargs):
        """Genera un video desde un prompt si el proveedor lo soporta"""
        if not self.supports_videos:
            return None, "Este proveedor no soporta generación de videos"
        return None, "Método no implementado"

class LMStudioProvider(LLMProvider):
    """Proveedor para LLM Studio (open source)"""
    def __init__(self, api_key="lm-studio", base_url="http://localhost:1234/v1"):
        super().__init__(api_key)
        self.base_url = base_url
        self.models = [
            "meta-llama-3.1-8b-instruct",
            "meta-llama-3.1-70b-instruct",
            "mistral-small",
            "neural-chat-7b",
            "phi-3-medium-4k"
        ]  # Modelos comunes
        self.max_token_limit = 8192
        self.supports_images = False
        self.supports_videos = False
        self.supports_thinking = False
        
    def initialize(self):
        try:
            self.client = OpenAI(base_url=self.base_url, api_key=self.api_key)
            logger.info(f"Conexión con LM Studio inicializada en {self.base_url}")
            
            # Intentar obtener la lista de modelos reales del servidor
            try:
                available_models = self.client.models.list()
                if hasattr(available_models, 'data') and available_models.data:
                    self.models = [model.id for model in available_models.data]
                    logger.info(f"Modelos disponibles en LM Studio: {', '.join(self.models)}")
            except Exception as model_e:
                logger.warning(f"No se pudieron obtener modelos de LM Studio: {str(model_e)}")
                # Mantener los modelos por defecto
                
            return True
        except Exception as e:
            logger.error(f"Error al inicializar LM Studio: {str(e)}")
            return False
        
    def generate_response(self, messages, model, temperature, max_tokens=None, **kwargs):
        try:
            if max_tokens is None or max_tokens <= 0:
                max_tokens = self.max_token_limit
                
            completion = self.client.chat.completions.create(
                model=model,
                messages=messages,
                temperature=temperature,
                max_tokens=max_tokens
            )
            return completion.choices[0].message.content.strip()
        except Exception as e:
            error_msg = f"Error en comunicación con LM Studio: {str(e)}"
            logger.error(error_msg)
            return error_msg

class AnthropicProvider(LLMProvider):
    """Proveedor para Anthropic Claude"""
    def __init__(self, api_key=None):
        super().__init__(api_key)
        self.models = [
            "claude-3-sonnet-20240229",
            "claude-3-haiku-20240307",
            "claude-3-opus-20240229",
            "claude-3.5-sonnet-20240620",
            "claude-3-5-sonnet-20241022",
            "claude-3-5-haiku-20241022",
            "claude-3-7-sonnet-20250219",
        ]
        self.thinking_models = [
            "claude-3-7-sonnet-20250219"
        ]
        self.token_limits = {
            "claude-3-sonnet-20240229": 200000,
            "claude-3-haiku-20240307": 200000,
            "claude-3-opus-20240229": 200000,
            "claude-3.5-sonnet-20240620": 200000,
            "claude-3-5-sonnet-20241022": 200000,
            "claude-3-5-haiku-20241022": 200000,
            "claude-3-7-sonnet-20250219": 200000,
        }
        self.max_token_limit = 32000  # Usando un valor conservador para la respuesta
        self.supports_images = True
        self.supports_videos = False
        self.supports_thinking = True
        
    def initialize(self):
        if not anthropic_available:
            logger.error("Librería Anthropic no está instalada. Instala con: pip install anthropic")
            return False
            
        if not self.api_key:
            logger.error("API Key de Anthropic no proporcionada")
            return False
            
        try:
            self.client = anthropic.Anthropic(api_key=self.api_key)
            logger.info("Conexión con Anthropic Claude inicializada")
            
            # Verificar si podemos obtener los modelos disponibles
            try:
                # Anthropic no proporciona una API oficial para listar modelos,
                # por lo que nos basamos en valores predefinidos
                logger.info(f"Modelos Anthropic configurados: {', '.join(self.models)}")
            except Exception as e:
                logger.warning(f"No se pudieron verificar modelos de Anthropic: {str(e)}")
                
            return True
        except Exception as e:
            logger.error(f"Error al inicializar Anthropic: {str(e)}")
            return False
        
    def generate_response(self, messages, model, temperature, max_tokens=None, stream=True, 
                          thinking=False, thinking_budget=1000, **kwargs):
        if not self.client:
            return "Error: Cliente Anthropic no inicializado"
            
        try:
            # Ajustar tokens máximos para no exceder el límite del modelo
            model_limit = self.token_limits.get(model, 32000)
            
            if max_tokens is None or max_tokens <= 0 or max_tokens > model_limit:
                max_tokens = min(model_limit, self.max_token_limit)
                logger.info(f"Ajustando max_tokens a {max_tokens} para modelo {model}")
            
            # Convertir mensajes de formato OpenAI a formato Anthropic
            anthropic_messages = []
            system_content = ""
            
            # Extraer mensajes de sistema y juntar en uno solo
            for msg in messages:
                if msg["role"] == "system":
                    system_content += msg["content"] + "\n"
            
            # Procesar el resto de mensajes
            for msg in messages:
                if msg["role"] == "user":
                    content = msg["content"]
                    # Verificar si hay contenido multimodal (imágenes)
                    if isinstance(content, list):
                        # Convertir formato multimodal
                        anthropic_content = []
                        for item in content:
                            if isinstance(item, str):
                                anthropic_content.append({"type": "text", "text": item})
                            elif isinstance(item, dict) and item.get("type") == "image_url":
                                # Formato OpenAI: {"type": "image_url", "image_url": {"url": "data:..."}}
                                image_url = item.get("image_url", {}).get("url", "")
                                if image_url.startswith("data:image"):
                                    anthropic_content.append({
                                        "type": "image",
                                        "source": {"type": "base64", "media_type": "image/jpeg", "data": image_url.split(",")[1]}
                                    })
                                else:
                                    anthropic_content.append({
                                        "type": "image",
                                        "source": {"type": "url", "url": image_url}
                                    })
                        anthropic_messages.append({"role": "user", "content": anthropic_content})
                    else:
                        anthropic_messages.append({"role": "user", "content": content})
                elif msg["role"] == "assistant":
                    anthropic_messages.append({"role": "assistant", "content": msg["content"]})
            
            # Configurar parámetros para la solicitud
            message_params = {
                "model": model,
                "messages": anthropic_messages,
                "temperature": temperature,
                "max_tokens": max_tokens,
                "stream": stream  # Siempre usar streaming para Anthropic
            }
            
            # Agregar sistema si hay contenido
            if system_content:
                message_params["system"] = system_content
                
            # Configurar modo Thinking para modelos que lo soportan
            use_thinking = thinking and model in self.thinking_models
            if use_thinking:
                logger.info(f"Usando modo Thinking con budget de {thinking_budget} tokens")
                message_params["tool_choice"] = "auto"
                message_params["tools"] = [
                    {
                        "name": "thinking",
                        "description": "Herramienta para pensar paso a paso y razonar",
                        "input_schema": {
                            "type": "object",
                            "properties": {
                                "thinking": {
                                    "type": "string",
                                    "description": "Razonamiento paso a paso"
                                }
                            },
                            "required": ["thinking"]
                        }
                    }
                ]
                message_params["tool_budget"] = thinking_budget
            
            logger.info(f"Llamada a Anthropic con modelo: {model}, max_tokens: {max_tokens}, streaming: {stream}")
            
            # Stream the response
            response_text = ""
            thinking_text = ""
            
            with self.client.messages.create(**message_params) as stream:
                for chunk in stream:
                    # Manejar el contenido de pensamiento
                    if use_thinking and hasattr(chunk, 'usage') and hasattr(chunk.usage, 'tool_calls') and chunk.usage.tool_calls:
                        for call in chunk.usage.tool_calls:
                            if hasattr(call, 'tool') and call.tool == 'thinking':
                                if hasattr(call, 'tokens'):
                                    thinking_budget_left = thinking_budget - call.tokens
                                    logger.info(f"Tokens usados en Thinking: {call.tokens} (quedan {thinking_budget_left})")
                    
                    # Manejar herramientas            
                    if hasattr(chunk, 'delta') and hasattr(chunk.delta, 'tool_calls') and chunk.delta.tool_calls:
                        for call in chunk.delta.tool_calls:
                            if hasattr(call, 'input') and hasattr(call.input, 'thinking'):
                                thinking_text += call.input.thinking or ""
                    
                    # Manejar texto normal
                    if hasattr(chunk, 'delta') and hasattr(chunk.delta, 'text'):
                        if chunk.delta.text:
                            response_text += chunk.delta.text
            
            # Si usamos el modo thinking y hay contenido de pensamiento, añadirlo al inicio
            if use_thinking and thinking_text:
                logger.info(f"Se generó texto de pensamiento ({len(thinking_text)} caracteres)")
                return f"[Pensamiento]\n{thinking_text}\n\n[Respuesta]\n{response_text}"
            else:
                return response_text
                
        except Exception as e:
            error_msg = f"Error con Anthropic: {str(e)}"
            logger.error(error_msg)
            return error_msg
            
    def generate_image(self, prompt, size="1024x1024", **kwargs):
        """
        Claude no tiene generación de imágenes nativa, pero puede crear descripciones detalladas
        para una herramienta de imagen secundaria
        """
        if not self.client:
            return None, "Error: Cliente Anthropic no inicializado"
            
        try:
            # Usar Claude para crear una descripción detallada para generación de imagen
            prompt_template = f"""
            Crea una descripción detallada para generar una imagen basada en: "{prompt}"
            
            Tu descripción debe ser detallada e incluir:
            - Sujeto principal y elementos de la escena
            - Estilo visual, colores dominantes y atmósfera
            - Iluminación y estado de ánimo
            - Perspectiva y composición
            
            Formatea la descripción como un prompt claro para alimentar a un generador de imágenes.
            """
            
            # Usar un modelo simple para la descripción
            model = "claude-3-haiku-20240307"  # Usar un modelo económico y rápido
            
            messages = [
                {"role": "user", "content": prompt_template}
            ]
            
            response = self.client.messages.create(
                model=model,
                messages=messages,
                max_tokens=1000,
                temperature=0.7
            )
            
            enhanced_prompt = response.content[0].text
            
            # Como Anthropic no puede generar la imagen directamente, devolvemos la descripción
            # mejorada para que pueda usarse con otra API de generación
            return None, f"[Claude no puede generar imágenes directamente, pero ha creado esta descripción mejorada]:\n\n{enhanced_prompt}"
            
        except Exception as e:
            error_msg = f"Error al generar descripción de imagen con Anthropic: {str(e)}"
            logger.error(error_msg)
            return None, error_msg

class OpenAIProvider(LLMProvider):
    """Proveedor para OpenAI GPT"""
    def __init__(self, api_key=None):
        super().__init__(api_key)
        self.models = [
            "gpt-4o-2024-05-13",   # GPT-4o
            "gpt-4-turbo-2024-04-09",  # GPT-4 Turbo
            "gpt-4o-mini-2024-07-18",  # GPT-4o mini
            "gpt-4-turbo-preview",     # Preview del último modelo
            "gpt-3.5-turbo-0125",      # Modelo económico
            "gpt-4-vision-preview"     # Con capacidad vision
        ]
        self.vision_models = [
            "gpt-4o-2024-05-13",
            "gpt-4-vision-preview",
            "gpt-4o-mini-2024-07-18"
        ]
        self.token_limits = {
            "gpt-4o-2024-05-13": 128000,
            "gpt-4-turbo-2024-04-09": 128000,
            "gpt-4o-mini-2024-07-18": 128000,
            "gpt-4-turbo-preview": 128000,
            "gpt-3.5-turbo-0125": 16000,
            "gpt-4-vision-preview": 128000
        }
        self.max_token_limit = 32000  # Valor conservador para la respuesta
        self.supports_images = True
        self.supports_videos = True
        self.supports_thinking = False
        
    def initialize(self):
        if not self.api_key:
            logger.error("API Key de OpenAI no proporcionada")
            return False
            
        try:
            self.client = OpenAI(api_key=self.api_key)
            logger.info("Conexión con OpenAI inicializada")
            
            # Intentar obtener la lista de modelos disponibles
            try:
                available_models = self.client.models.list()
                if hasattr(available_models, 'data') and available_models.data:
                    # Filtrar solo los modelos de chat GPT
                    gpt_models = [model.id for model in available_models.data 
                                if model.id.startswith(('gpt-3', 'gpt-4'))]
                    
                    if gpt_models:
                        # Actualizar la lista de modelos, pero mantener primero los principales
                        # y después agregar cualquier otro que esté disponible
                        main_models = [m for m in self.models]
                        other_models = [m for m in gpt_models if m not in self.models]
                        self.models = main_models + other_models
                        
                    logger.info(f"Modelos GPT disponibles: {', '.join(self.models[:5])}...")
            except Exception as model_e:
                logger.warning(f"No se pudieron obtener modelos de OpenAI: {str(model_e)}")
                # Mantener los modelos predefinidos
                
            return True
        except Exception as e:
            logger.error(f"Error al inicializar OpenAI: {str(e)}")
            return False
        
    def generate_response(self, messages, model, temperature, max_tokens=None, stream=False, **kwargs):
        if not self.client:
            return "Error: Cliente OpenAI no inicializado"
            
        try:
            # Ajustar tokens máximos basado en el modelo
            model_limit = self.token_limits.get(model, 16000)
            
            if max_tokens is None or max_tokens <= 0 or max_tokens > model_limit:
                max_tokens = min(model_limit, self.max_token_limit)
                logger.info(f"Ajustando max_tokens a {max_tokens} para modelo {model}")
            
            # Verificar si hay contenido multimodal en los mensajes
            has_images = False
            for msg in messages:
                if isinstance(msg.get("content"), list):
                    for item in msg["content"]:
                        if isinstance(item, dict) and item.get("type") == "image_url":
                            has_images = True
                            break
            
            # Si hay imágenes y el modelo no soporta visión, cambiar a uno que sí
            if has_images and model not in self.vision_models:
                old_model = model
                model = "gpt-4o-2024-05-13"  # Usar el modelo más reciente con visión
                logger.warning(f"Cambiando modelo de {old_model} a {model} para soportar imágenes")
                
            # Configurar parámetros para la solicitud
            params = {
                "model": model,
                "messages": messages,
                "temperature": temperature,
                "max_tokens": max_tokens,
                "stream": stream
            }
            
            # Manejar el streaming si está activado
            if stream:
                response_text = ""
                for chunk in self.client.chat.completions.create(**params):
                    if hasattr(chunk.choices[0].delta, 'content') and chunk.choices[0].delta.content:
                        content = chunk.choices[0].delta.content
                        response_text += content
                        
                return response_text
            else:
                # Respuesta normal sin streaming
                completion = self.client.chat.completions.create(**params)
                return completion.choices[0].message.content.strip()
                
        except Exception as e:
            error_msg = f"Error con OpenAI: {str(e)}"
            logger.error(error_msg)
            return error_msg
    
    def generate_image(self, prompt, size="1024x1024", model="dall-e-3", quality="standard", style="vivid", **kwargs):
        """
        Genera una imagen usando DALL-E de OpenAI
        
        Args:
            prompt: Texto descriptivo para la imagen
            size: Tamaño de la imagen (1024x1024, 1024x1792, 1792x1024)
            model: dall-e-2 o dall-e-3
            quality: standard o hd (solo para dall-e-3)
            style: vivid o natural (solo para dall-e-3)
        """
        if not self.client:
            return None, "Error: Cliente OpenAI no inicializado"
            
        try:
            # Validar parámetros
            valid_sizes = ["256x256", "512x512", "1024x1024", "1024x1792", "1792x1024"]
            if size not in valid_sizes:
                size = "1024x1024"
                
            # DALL-E 3 solo soporta 1024x1024, 1024x1792, 1792x1024
            if model == "dall-e-3" and size in ["256x256", "512x512"]:
                size = "1024x1024"
                
            # Configurar parámetros según el modelo
            params = {
                "model": model,
                "prompt": prompt,
                "size": size,
                "n": 1
            }
            
            # Parámetros adicionales para DALL-E 3
            if model == "dall-e-3":
                params["quality"] = quality
                params["style"] = style
                
            # Generar la imagen
            response = self.client.images.generate(**params)
            
            if response.data and len(response.data) > 0:
                # Extraer URL y datos adicionales
                image_url = response.data[0].url
                
                # También extraer la revisión del prompt si está disponible
                revised_prompt = response.data[0].revised_prompt if hasattr(response.data[0], 'revised_prompt') else None
                
                # Descargar la imagen localmente
                image_data = None
                local_path = None
                
                try:
                    # Descargar imagen de la URL
                    image_response = requests.get(image_url)
                    image_data = BytesIO(image_response.content)
                    
                    # Guardar localmente
                    timestamp = int(time.time())
                    local_path = f"generated_image_{timestamp}.png"
                    
                    with open(local_path, "wb") as img_file:
                        img_file.write(image_response.content)
                        
                    logger.info(f"Imagen guardada localmente en: {local_path}")
                except Exception as img_err:
                    logger.error(f"Error al guardar imagen localmente: {str(img_err)}")
                
                return {
                    "url": image_url,
                    "local_path": local_path,
                    "data": image_data,
                    "revised_prompt": revised_prompt
                }, "Imagen generada correctamente"
            else:
                return None, "No se pudo generar la imagen"
                
        except Exception as e:
            error_msg = f"Error al generar imagen con DALL-E: {str(e)}"
            logger.error(error_msg)
            return None, error_msg
            
    def generate_video(self, prompt, duration=5, model="sora-1.0-turbo", quality="standard", **kwargs):
        """
        Genera un video usando Sora de OpenAI (preview/simulación)
        
        Args:
            prompt: Texto descriptivo para el video
            duration: Duración en segundos (1-60)
            model: Modelo de Sora a utilizar
            quality: standard o hd
        """
        if not self.client:
            return None, "Error: Cliente OpenAI no inicializado"
        
        # Actualmente Sora no está disponible en la API pública.
        # Este es un placeholder para cuando esté disponible.
        
        try:
            # Validar duración
            if duration < 1:
                duration = 1
            elif duration > 60:
                duration = 60
                
            # Usar GPT-4o para generar una descripción detallada de cómo sería el video
            description_prompt = f"""
            Actúa como un generador de videos profesional. Describe con gran detalle cómo sería un video 
            de {duration} segundos basado en esta descripción: "{prompt}"
            
            Tu descripción debe incluir:
            - Descripción del contenido frame por frame
            - Movimientos de cámara
            - Iluminación y color
            - Transiciones
            - Audio o música que acompañaría
            
            Formatea tu descripción como un guión técnico detallado.
            """
            
            # Generar la descripción con GPT-4
            description_response = self.client.chat.completions.create(
                model="gpt-4o-2024-05-13",
                messages=[{"role": "user", "content": description_prompt}],
                temperature=0.7,
                max_tokens=1000
            )
            
            video_description = description_response.choices[0].message.content.strip()
            
            # Generar una imagen de un frame representativo para simular el video
            frame_prompt = f"Un solo frame de un video que muestra: {prompt}. Debe ser cinematográfico y de alta calidad."
            
            image_result, image_msg = self.generate_image(frame_prompt, size="1024x1024", model="dall-e-3", quality="hd")
            
            if image_result:
                return {
                    "type": "video_simulation",
                    "frame_image": image_result,
                    "description": video_description,
                    "prompt": prompt,
                    "duration": duration
                }, "Sora no está disponible actualmente en la API pública. Este es un frame representativo con una descripción detallada."
            else:
                return None, f"No se pudo simular el video. Error en la generación de imagen: {image_msg}"
                
        except Exception as e:
            error_msg = f"Error al simular video con Sora: {str(e)}"
            logger.error(error_msg)
            return None, error_msg

class GeminiProvider(LLMProvider):
    """Proveedor para Google Gemini"""
    def __init__(self, api_key=None):
        super().__init__(api_key)
        self.models = [
            "gemini-1.5-pro-latest",
            "gemini-1.5-flash-latest",
            "gemini-1.0-pro-latest",
            "gemini-1.5-pro-preview-0514", # Gemini 2.5 Pro Preview
            "gemini-1.5-flash-preview-0514"
        ]
        self.vision_models = [
            "gemini-1.5-pro-latest",
            "gemini-1.5-pro-preview-0514"
        ]
        self.token_limits = {
            "gemini-1.5-pro-latest": 1000000,  # 1M tokens
            "gemini-1.5-flash-latest": 1000000,
            "gemini-1.0-pro-latest": 30000,
            "gemini-1.5-pro-preview-0514": 2000000, # 2M tokens
            "gemini-1.5-flash-preview-0514": 1000000
        }
        self.max_token_limit = 32000  # Valor conservador para la respuesta
        self.supports_images = True
        self.supports_videos = False
        self.supports_thinking = False
        
    def initialize(self):
        if not genai_available:
            logger.error("Librería de Google Generative AI no está instalada. Instala con: pip install google-generativeai")
            return False
            
        if not self.api_key:
            logger.error("API Key de Google no proporcionada")
            return False
            
        try:
            genai.configure(api_key=self.api_key)
            
            # Verificar si podemos obtener los modelos disponibles
            try:
                # Listar modelos disponibles
                models_info = genai.list_models()
                available_models = []
                
                for model in models_info:
                    if "generateContent" in model.supported_generation_methods:
                        available_models.append(model.name)
                
                if available_models:
                    # Extraer solo la parte del nombre después de 'models/'
                    cleaned_models = []
                    for model_path in available_models:
                        if '/' in model_path:
                            model_name = model_path.split('/')[-1]
                            cleaned_models.append(model_name)
                        else:
                            cleaned_models.append(model_path)
                    
                    # Actualizar la lista de modelos, manteniendo primero los principales
                    main_models = [m for m in self.models]
                    other_models = [m for m in cleaned_models if m not in self.models]
                    self.models = main_models + other_models
                    
                logger.info(f"Modelos Gemini disponibles: {', '.join(self.models[:5])}...")
                
            except Exception as model_e:
                logger.warning(f"No se pudieron obtener modelos de Gemini: {str(model_e)}")
                # Mantener los modelos predefinidos
            
            logger.info("Conexión con Google Gemini inicializada")
            return True
        except Exception as e:
            logger.error(f"Error al inicializar Gemini: {str(e)}")
            return False
        
    def generate_response(self, messages, model, temperature, max_tokens=None, stream=False, **kwargs):
        if not genai_available:
            return "Error: Cliente Gemini no disponible, instala google-generativeai"
            
        try:
            # Convertir mensajes de formato OpenAI a formato Gemini
            gemini_messages = []
            system_content = ""
            
            # Extraer mensajes de sistema
            for msg in messages:
                if msg["role"] == "system":
                    system_content += msg["content"] + "\n"
            
            # Procesar el resto de mensajes
            for msg in messages:
                if msg["role"] == "user":
                    content = msg["content"]
                    parts = []
                    
                    # Manejar contenido multimodal (texto + imágenes)
                    if isinstance(content, list):
                        for item in content:
                            if isinstance(item, str):
                                parts.append(item)
                            elif isinstance(item, dict) and item.get("type") == "image_url":
                                image_url = item.get("image_url", {}).get("url", "")
                                if image_url.startswith("data:image"):
                                    # Manejar imágenes en base64
                                    image_data = image_url.split(",")[1]
                                    image_bytes = base64.b64decode(image_data)
                                    parts.append({
                                        "inline_data": {
                                            "data": base64.b64encode(image_bytes).decode("utf-8"),
                                            "mime_type": "image/jpeg"
                                        }
                                    })
                                else:
                                    # Manejar imágenes por URL
                                    try:
                                        # Gemini prefiere imágenes como bytes, no URLs directas
                                        response = requests.get(image_url)
                                        image_bytes = response.content
                                        parts.append({
                                            "inline_data": {
                                                "data": base64.b64encode(image_bytes).decode("utf-8"),
                                                "mime_type": response.headers.get("Content-Type", "image/jpeg")
                                            }
                                        })
                                    except Exception as img_e:
                                        logger.warning(f"No se pudo cargar imagen de URL: {str(img_e)}")
                                        parts.append(f"[No se pudo cargar imagen de {image_url}]")
                    else:
                        parts.append(content)
                    
                    gemini_messages.append({"role": "user", "parts": parts})
                elif msg["role"] == "assistant":
                    gemini_messages.append({"role": "model", "parts": [msg["content"]]})
            
            # Ajustar tokens máximos
            model_limit = self.token_limits.get(model, 30000)
            
            if max_tokens is None or max_tokens <= 0 or max_tokens > model_limit:
                max_tokens = min(model_limit, self.max_token_limit)
                logger.info(f"Ajustando max_tokens a {max_tokens} para modelo {model}")
            
            # Verificar si hay imágenes y seleccionar un modelo compatible
            has_images = False
            for msg in gemini_messages:
                for part in msg.get("parts", []):
                    if isinstance(part, dict) and "inline_data" in part:
                        has_images = True
                        break
            
            # Si hay imágenes y el modelo no es compatible, cambiar a uno que sí lo sea
            if has_images and model not in self.vision_models:
                old_model = model
                model = "gemini-1.5-pro-latest"  # Usar el modelo más reciente con visión
                logger.warning(f"Cambiando modelo de {old_model} a {model} para soportar imágenes")
            
            # Normalizar el nombre del modelo para la API
            if not model.startswith("models/"):
                model_name = f"models/{model}"
            else:
                model_name = model
            
            # Crear configuración
            generation_config = {
                "temperature": temperature,
                "max_output_tokens": max_tokens,
                "top_p": 0.95,
                "top_k": 64
            }
            
            # Configurar límites de seguridad (más permisivos pero seguros)
            safety_settings = {
                HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            }
            
            # Si hay contenido de sistema, agregarlo al primer mensaje del usuario
            if system_content and gemini_messages and gemini_messages[0]["role"] == "user":
                if isinstance(gemini_messages[0]["parts"][0], str):
                    gemini_messages[0]["parts"][0] = f"{system_content}\n\n{gemini_messages[0]['parts'][0]}"
            
            # Inicializar modelo
            gemini_model = genai.GenerativeModel(
                model_name=model_name,
                generation_config=generation_config,
                safety_settings=safety_settings
            )
            
            # Generar respuesta con o sin streaming
            if stream:
                response_text = ""
                for chunk in gemini_model.generate_content(gemini_messages, stream=True):
                    if hasattr(chunk, 'text'):
                        response_text += chunk.text
                return response_text
            else:
                # Generar respuesta normal
                response = gemini_model.generate_content(gemini_messages)
                return response.text
                
        except Exception as e:
            error_msg = f"Error con Gemini: {str(e)}"
            logger.error(error_msg)
            return error_msg
            
    def generate_image(self, prompt, size="1024x1024", **kwargs):
        """
        Gemini actualmente no tiene una API oficial para generación de imágenes.
        Esta función utiliza la capacidad de texto a imagen de Imagen, simulada a través de una descripción.
        """
        if not genai_available:
            return None, "Error: Cliente Gemini no disponible, instala google-generativeai"
            
        try:
            # Usar Gemini Pro para crear una descripción detallada para la generación de imagen
            model_name = "models/gemini-1.5-pro-latest"
            
            prompt_template = f"""
            Crea una descripción detallada para generar una imagen de alta calidad basada en: "{prompt}"
            
            La descripción debe ser extremadamente detallada e incluir:
            - Sujeto principal y elementos de la escena
            - Estilo visual específico, técnica artística y referentes
            - Paleta de colores, iluminación y atmósfera
            - Textura, materiales y acabados visuales
            - Perspectiva, composición y enfoque
            
            La descripción debe estar optimizada para obtener el mejor resultado posible de un generador de imágenes AI.
            """
            
            gemini_model = genai.GenerativeModel(model_name=model_name)
            response = gemini_model.generate_content(prompt_template)
            
            enhanced_prompt = response.text
            
            return None, f"[Gemini actualmente no proporciona generación de imágenes directamente en su API pública, pero ha creado esta descripción mejorada]:\n\n{enhanced_prompt}"
            
        except Exception as e:
            error_msg = f"Error al generar descripción de imagen con Gemini: {str(e)}"
            logger.error(error_msg)
            return None, error_msg

# Variable global para mantener el proveedor activo
current_llm_provider = None

# Función para crear y obtener el proveedor según el tipo
def get_llm_provider(provider_type, api_key=None, base_url=None):
    """Crea un proveedor de LLM según el tipo especificado"""
    if provider_type == "lm-studio":
        return LMStudioProvider(api_key=api_key or "lm-studio", base_url=base_url or "http://localhost:1234/v1")
    elif provider_type == "anthropic":
        return AnthropicProvider(api_key=api_key)
    elif provider_type == "openai":
        return OpenAIProvider(api_key=api_key)
    elif provider_type == "gemini":
        return GeminiProvider(api_key=api_key)
    else:
        logger.warning(f"Tipo de proveedor desconocido: {provider_type}, usando LM Studio")
        return LMStudioProvider()

###############################################################################
#                     LIMPIEZA DE CACHÉ WIN32COM
###############################################################################
def clear_win32com_cache():
    """Limpia la caché de win32com para evitar errores con COM"""
    logger.info("Limpiando caché de win32com...")
    try:
        # Obtener la ruta del directorio de caché
        cache_dir = os.path.join(os.environ.get('LOCALAPPDATA', os.path.expanduser('~')), 
                                 'Temp', 'gen_py')
        
        # Verificar si existe y eliminar
        if os.path.exists(cache_dir):
            logger.info(f"Eliminando directorio de caché: {cache_dir}")
            shutil.rmtree(cache_dir, ignore_errors=True)
            return True
        else:
            logger.info("No se encontró directorio de caché para limpiar")
            return True
    except Exception as e:
        logger.error(f"Error al limpiar caché de win32com: {str(e)}")
        return False

###############################################################################
#                      UTILIDADES PARA DESCARGAS DIRECTAS
###############################################################################
def clean_youtube_url(url):
    """Limpia y normaliza una URL de YouTube para extraer el ID del video correctamente"""
    # Registrar la URL original para debugging
    logger.info(f"URL original a limpiar: {url}")
    
    # Patrones comunes de URL de YouTube
    patterns = [
        r'(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})',
        r'(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})',
    ]
    
    for pattern in patterns:
        match = re.search(pattern, url)
        if match:
            video_id = match.group(1)
            cleaned_url = f"https://www.youtube.com/watch?v={video_id}"
            logger.info(f"URL limpiada: {cleaned_url}")
            return cleaned_url
    
    # Si no coincide con ningún patrón, devolver la URL original
    logger.warning(f"No se pudo limpiar URL: {url} - usando original")
    return url

def direct_download_media(url, is_audio=False, format_type="mp4"):
    """Descarga multimedia directamente permitiendo elegir carpeta destino"""
    if not url:
        logger.error("URL vacía proporcionada para descarga")
        return False, "URL vacía"
    
    # Limpia y normaliza la URL
    logger.info(f"Iniciando descarga desde URL: {url}")
    cleaned_url = clean_youtube_url(url)
    logger.info(f"URL limpia a usar: {cleaned_url}")
    
    # Usar el Escritorio como ubicación predeterminada
    default_path = os.path.expanduser("~/Desktop")
    logger.info(f"Ruta predeterminada: {default_path}")
    
    # Configurar Tkinter para diálogo de carpeta
    try:
        # Crear ventana Tk para diálogos
        root = tk.Tk()
        root.withdraw()  # Ocultar ventana principal
        root.attributes('-topmost', True)  # Asegurar que aparezca en primer plano
        
        # Mostrar diálogo en primer plano
        logger.info("Mostrando diálogo para seleccionar carpeta destino...")
        print("\n[ACCIÓN REQUERIDA] Por favor selecciona la carpeta donde guardar la descarga.")
        
        save_path = filedialog.askdirectory(
            title="Selecciona dónde guardar la descarga",
            initialdir=default_path
        )
        
        # Si el usuario cancela, usar la ubicación predeterminada
        if not save_path:
            save_path = default_path
            logger.info(f"No se seleccionó carpeta, usando predeterminada: {save_path}")
        else:
            logger.info(f"Carpeta seleccionada: {save_path}")
    except Exception as e:
        logger.error(f"Error al mostrar diálogo de carpeta: {str(e)}")
        save_path = default_path
        logger.info(f"Usando carpeta predeterminada debido a error: {save_path}")
    
    # Verificar que existe la carpeta destino
    if not os.path.exists(save_path):
        logger.info(f"Creando carpeta destino: {save_path}")
        try:
            os.makedirs(save_path)
        except Exception as e:
            logger.error(f"Error al crear carpeta destino: {str(e)}")
            return False, f"Error al crear carpeta destino: {str(e)}"
    
    # Inicia la descarga en un hilo separado
    # Usar un hilo daemon para que termine cuando la aplicación principal termine
    download_thread = threading.Thread(
        target=_direct_download_thread,
        args=(cleaned_url, save_path, is_audio, format_type),
        daemon=True
    )
    
    logger.info(f"Iniciando hilo de descarga para {cleaned_url}")
    download_thread.start()
    
    return True, f"Descarga iniciada: {url} como {'audio' if is_audio else 'video'} en formato {format_type}. Se guardará en {save_path}."

def _direct_download_thread(url, save_path, is_audio, format_type):
    """Función de hilo para descargar multimedia con barra de progreso mejorada"""
    logger.info(f"Hilo de descarga iniciado para {url}")
    print(f"\n[DESCARGA] Iniciando descarga desde {url}")
    print(f"[DESCARGA] Guardando {'audio' if is_audio else 'video'} en: {save_path}")
    
    try:
        # Verificar que la carpeta destino existe
        if not os.path.exists(save_path):
            logger.info(f"Creando carpeta destino desde el hilo: {save_path}")
            os.makedirs(save_path)
        
        logger.info(f"Obteniendo información del video: {url}")
        print(f"[DESCARGA] Obteniendo información del video...")
        
        # Obtener el título con más opciones para mejorar la compatibilidad
        info_opts = {
            'quiet': False,
            'no_warnings': False,
            'ignoreerrors': False,
            'geo_bypass': True,
            'nocheckcertificate': True,
        }
        
        # Variable para almacenar información del video
        video_info = None
        
        with yt_dlp.YoutubeDL(info_opts) as ydl:
            try:
                info_dict = ydl.extract_info(url, download=False)
                if info_dict is None:
                    raise Exception("No se pudo obtener información del video")
                
                # Guardar info para uso posterior
                video_info = info_dict
                
                video_title = info_dict.get('title', 'video')
                safe_title = "".join([c if c.isalnum() or c in ' ._-' else '_' for c in video_title])
                logger.info(f"Título del video: {video_title}")
                print(f"[DESCARGA] Título: {video_title}")
                
                # Mostrar detalles adicionales si están disponibles
                if 'duration' in info_dict:
                    mins, secs = divmod(info_dict['duration'], 60)
                    print(f"[DESCARGA] Duración: {mins}:{secs:02d}")
                
                if 'channel' in info_dict:
                    print(f"[DESCARGA] Canal: {info_dict['channel']}")
            except Exception as info_error:
                logger.error(f"Error al obtener información: {str(info_error)}")
                print(f"[ERROR] No se pudo obtener información: {str(info_error)}")
                # Usar un título genérico si no se puede obtener el real
                import uuid
                safe_title = f"video_{uuid.uuid4().hex[:8]}"
        
        # Crear directorio temporal para la descarga
        temp_dir = os.path.join(save_path, f".temp_{int(time.time())}")
        logger.info(f"Creando directorio temporal: {temp_dir}")
        os.makedirs(temp_dir, exist_ok=True)
        
        # Función mejorada para mostrar progreso con barra visual
        def progress_hook(d):
            if d['status'] == 'downloading':
                percent = d.get('_percent_str', 'desconocido')
                speed = d.get('_speed_str', 'desconocido')
                eta = d.get('_eta_str', 'desconocido')
                downloaded = d.get('downloaded_bytes', 0)
                total = d.get('total_bytes', 0) or d.get('total_bytes_estimate', 0)
                
                # Crear barra de progreso en texto
                if total > 0:
                    bar_length = 40
                    progress = downloaded / total
                    block = int(round(bar_length * progress))
                    progress_bar = "█" * block + "░" * (bar_length - block)
                    
                    status_line = f"\r[PROGRESO] |{progress_bar}| {percent} @ {speed}, ETA: {eta}"
                    print(status_line, end="")
                    sys.stdout.flush()  # Forzar actualización inmediata
                else:
                    status_line = f"\r[DESCARGANDO] {percent} @ {speed}, ETA: {eta}"
                    print(status_line, end="")
                    sys.stdout.flush()  # Forzar actualización inmediata
                
                # Registrar progreso periódicamente (no cada iteración para evitar sobrecarga)
                if downloaded % (1024*1024*5) < 1024:  # Cada ~5MB
                    logger.info(f"Progreso: {percent} a {speed}, ETA: {eta}")
            
            elif d['status'] == 'finished':
                print("\n[DESCARGA] Archivo descargado. Procesando...")
                logger.info("Descarga finalizada. Iniciando post-procesamiento.")
        
        # Configurar opciones de descarga mejoradas
        ydl_opts = {
            'format': "bestaudio/best" if is_audio else "best",
            'outtmpl': os.path.join(temp_dir, f"{safe_title}.%(ext)s"),
            'progress_hooks': [progress_hook],
            'quiet': False,
            'no_warnings': False,
            'verbose': True,  # Añadir verbose para más información
            'ignoreerrors': False,
            'geo_bypass': True,
            'nocheckcertificate': True,
        }
        
        if is_audio:
            logger.info(f"Configurando descarga de audio en formato {format_type}")
            ydl_opts['postprocessors'] = [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': format_type,
                'preferredquality': '192',
            }]
        
        # Imprimir confirmación de opciones
        print(f"[DESCARGA] Modo: {'Audio' if is_audio else 'Video'}, Formato: {format_type}")
        
        # Descargar con yt-dlp
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            logger.info(f"Iniciando descarga con yt-dlp: {url}")
            print(f"[DESCARGA] Iniciando descarga...")
            ydl.download([url])
        
        # Procesar los archivos descargados
        if is_audio:
            logger.info(f"Procesando archivos de audio descargados...")
            print(f"[DESCARGA] Procesando archivos de audio...")
            
            audio_files = glob.glob(os.path.join(temp_dir, f"*.{format_type}"))
            if audio_files:
                for file in audio_files:
                    dest_file = os.path.join(save_path, os.path.basename(file))
                    logger.info(f"Moviendo audio de {file} a {dest_file}")
                    
                    # Si existe el destino, eliminarlo primero
                    if os.path.exists(dest_file):
                        os.remove(dest_file)
                    
                    # Mover el archivo
                    os.rename(file, dest_file)
                    print(f"[COMPLETADO] Audio guardado como: {os.path.basename(dest_file)}")
                    logger.info(f"Audio guardado correctamente: {dest_file}")
            else:
                logger.warning(f"No se encontraron archivos de audio en {temp_dir}")
                print(f"[ADVERTENCIA] No se encontraron archivos de audio en formato esperado.")
                
                # Buscar cualquier archivo de audio que pueda haber sido generado
                any_audio = glob.glob(os.path.join(temp_dir, "*.mp3")) + \
                            glob.glob(os.path.join(temp_dir, "*.m4a")) + \
                            glob.glob(os.path.join(temp_dir, "*.opus")) + \
                            glob.glob(os.path.join(temp_dir, "*.wav"))
                
                if any_audio:
                    logger.info(f"Encontrados formatos de audio alternativos: {any_audio}")
                    print(f"[RECUPERACIÓN] Encontrados {len(any_audio)} archivos de audio en otros formatos.")
                    
                    for file in any_audio:
                        dest_file = os.path.join(save_path, os.path.basename(file))
                        
                        # Si existe el destino, eliminarlo primero
                        if os.path.exists(dest_file):
                            os.remove(dest_file)
                        
                        # Mover el archivo
                        os.rename(file, dest_file)
                        print(f"[COMPLETADO] Audio guardado como: {os.path.basename(dest_file)}")
                        logger.info(f"Audio alternativo guardado: {dest_file}")
        else:
            logger.info(f"Procesando archivos de video descargados...")
            print(f"[DESCARGA] Procesando archivos de video...")
            
            # Excluir archivos parciales o temporales
            video_files = glob.glob(os.path.join(temp_dir, "*.*"))
            video_files = [f for f in video_files if not f.endswith(('.part', '.ytdl'))]
            
            if not video_files:
                logger.warning(f"No se encontraron archivos de video en {temp_dir}")
                print(f"[ERROR] No se encontraron archivos de video.")
                
                # Listar todos los archivos en el directorio para diagnóstico
                all_files = os.listdir(temp_dir) if os.path.exists(temp_dir) else []
                logger.info(f"Archivos en directorio temporal: {all_files}")
                print(f"[DIAGNÓSTICO] Archivos en directorio temporal: {all_files}")
            else:
                # Procesar el primer archivo encontrado
                source_file = video_files[0]
                ext = os.path.splitext(source_file)[1][1:]
                
                # Si no se especificó formato, usar la extensión del archivo
                if not format_type:
                    format_type = ext if ext else "mp4"
                
                # Construir nombre de archivo final
                final_filename = f"{safe_title}.{format_type}"
                output_filename = os.path.join(save_path, final_filename)
                
                logger.info(f"Archivo fuente: {source_file}")
                logger.info(f"Extensión detectada: {ext}")
                logger.info(f"Guardando como: {output_filename}")
                
                print(f"[DESCARGA] Archivo original: {os.path.basename(source_file)}")
                
                # Si la extensión es diferente, realizar conversión
                if ext != format_type:
                    logger.info(f"Convirtiendo de {ext} a {format_type}...")
                    print(f"[PROCESANDO] Convirtiendo de formato {ext} a {format_type}...")
                    
                    # Comando FFmpeg para convertir
                    cmd = [
                        'ffmpeg', '-y', '-i', source_file,
                        '-c:v', 'libx264', '-preset', 'fast',
                        '-c:a', 'aac', '-b:a', '192k',
                        output_filename
                    ]
                    
                    logger.info(f"Ejecutando comando: {' '.join(cmd)}")
                    
                    # Ejecutar FFmpeg y capturar salida
                    process = subprocess.Popen(
                        cmd, 
                        stdout=subprocess.PIPE, 
                        stderr=subprocess.PIPE,
                        universal_newlines=True
                    )
                    
                    # Mostrar progreso de FFmpeg
                    for line in process.stderr:
                        if "time=" in line and "bitrate=" in line:
                            print(f"\r[CONVIRTIENDO] {line.strip()}", end="")
                    
                    # Esperar a que termine
                    process.wait()
                    logger.info(f"Resultado FFmpeg: {process.returncode}")
                    
                    # Verificar si la conversión fue exitosa
                    if not os.path.exists(output_filename) or os.path.getsize(output_filename) == 0:
                        logger.warning("Conversión fallida. Usando archivo original.")
                        print(f"\n[ADVERTENCIA] Conversión fallida. Usando archivo original.")
                        
                        # Usar el archivo original
                        fallback_output = os.path.join(save_path, os.path.basename(source_file))
                        if os.path.exists(fallback_output):
                            os.remove(fallback_output)
                        os.rename(source_file, fallback_output)
                        output_filename = fallback_output
                        logger.info(f"Archivo guardado sin convertir: {fallback_output}")
                        print(f"[COMPLETADO] Video guardado como: {os.path.basename(fallback_output)}")
                    else:
                        logger.info(f"Conversión exitosa: {output_filename}")
                        print(f"\n[COMPLETADO] Video convertido y guardado como: {os.path.basename(output_filename)}")
                else:
                    # Solo mover el archivo si la extensión ya es la deseada
                    logger.info(f"No es necesario convertir. Moviendo archivo...")
                    if os.path.exists(output_filename):
                        os.remove(output_filename)
                    os.rename(source_file, output_filename)
                    logger.info(f"Archivo guardado: {output_filename}")
                    print(f"[COMPLETADO] Video guardado como: {os.path.basename(output_filename)}")
        
        # Limpieza del directorio temporal
        try:
            logger.info(f"Limpiando directorio temporal: {temp_dir}")
            print(f"[LIMPIEZA] Eliminando archivos temporales...")
            
            for file in os.listdir(temp_dir):
                file_path = os.path.join(temp_dir, file)
                if os.path.isfile(file_path):
                    os.unlink(file_path)
            os.rmdir(temp_dir)
            logger.info(f"Directorio temporal limpiado correctamente")
        except Exception as e:
            logger.warning(f"Advertencia durante la limpieza: {str(e)}")
            print(f"[ADVERTENCIA] No se pudieron eliminar todos los archivos temporales: {str(e)}")
        
        print(f"\n[DESCARGA COMPLETA] {'Audio' if is_audio else 'Video'} guardado en: {save_path}")
        logger.info(f"Proceso de descarga completado exitosamente")
        
    except Exception as e:
        logger.error(f"Error durante la descarga directa: {str(e)}")
        print(f"\n[ERROR CRÍTICO] Durante la descarga: {str(e)}")
        
        # Intentar rescatar archivos parciales
        try:
            if 'temp_dir' in locals() and os.path.exists(temp_dir):
                partial_files = glob.glob(os.path.join(temp_dir, "*.*"))
                if partial_files:
                    logger.info(f"Intentando rescatar {len(partial_files)} archivos parciales")
                    print(f"[RECUPERACIÓN] Intentando rescatar archivos parcialmente descargados...")
                    
                    for file in partial_files:
                        # Solo rescatar archivos con tamaño significativo (más de 1MB)
                        if os.path.getsize(file) > 1024*1024:
                            dest_file = os.path.join(save_path, f"partial_{os.path.basename(file)}")
                            if os.path.exists(dest_file):
                                os.remove(dest_file)
                            os.rename(file, dest_file)
                            logger.info(f"Archivo parcial rescatado: {dest_file}")
                            print(f"[RECUPERADO] Archivo parcial: {os.path.basename(dest_file)}")
        except Exception as rescue_error:
            logger.error(f"Error durante el rescate de archivos: {str(rescue_error)}")
            print(f"[ERROR] Al intentar rescatar archivos: {str(rescue_error)}")

###############################################################################
#                      REPRODUCCIÓN MULTIMEDIA
###############################################################################
class MediaPlayerFrame(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent, padding="20")
        self.parent = parent
        
        # Variables de control
        self.current_audio = None
        self.current_video = None
        self.vlc_instance = None
        self.vlc_player = None
        self.is_playing = False
        self.playlist = []
        self.current_index = 0
        
        # Inicializar pygame para audio
        if pygame_available:
            pygame.mixer.init()
        
        # Inicializar VLC para video
        if vlc_available:
            self.vlc_instance = vlc.Instance("--no-xlib")
            self.vlc_player = self.vlc_instance.media_player_new()
        
        self.create_widgets()
    
    def create_widgets(self):
        # Título
        header_label = ttk.Label(self, text="Reproductor Multimedia", 
                                style="Header.TLabel", font=("Arial", 16, "bold"))
        header_label.pack(pady=10)
        
        # Marco para archivos
        file_frame = ttk.LabelFrame(self, text="Archivos")
        file_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Lista de reproducción
        playlist_frame = ttk.Frame(file_frame)
        playlist_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        scrollbar = ttk.Scrollbar(playlist_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.playlist_box = tk.Listbox(playlist_frame, yscrollcommand=scrollbar.set, 
                                      font=("Arial", 10), height=15)
        self.playlist_box.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=self.playlist_box.yview)
        
        self.playlist_box.bind("<Double-1>", self.play_selected)
        
        # Botones para gestionar archivos
        file_buttons_frame = ttk.Frame(file_frame)
        file_buttons_frame.pack(fill=tk.X, padx=5, pady=5)
        
        add_button = ttk.Button(file_buttons_frame, text="Añadir archivos", command=self.add_files)
        add_button.pack(side=tk.LEFT, padx=5)
        
        remove_button = ttk.Button(file_buttons_frame, text="Eliminar seleccionado", command=self.remove_selected)
        remove_button.pack(side=tk.LEFT, padx=5)
        
        clear_button = ttk.Button(file_buttons_frame, text="Limpiar lista", command=self.clear_playlist)
        clear_button.pack(side=tk.LEFT, padx=5)
        
        # Marco para controles de reproducción
        control_frame = ttk.LabelFrame(self, text="Controles")
        control_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Información de reproducción actual
        self.now_playing_var = tk.StringVar(value="No hay reproducción en curso")
        now_playing_label = ttk.Label(control_frame, textvariable=self.now_playing_var)
        now_playing_label.pack(fill=tk.X, padx=5, pady=5)
        
        # Controles básicos
        basic_controls = ttk.Frame(control_frame)
        basic_controls.pack(fill=tk.X, padx=5, pady=5)
        
        prev_button = ttk.Button(basic_controls, text="⏮", width=5, command=self.play_previous)
        prev_button.pack(side=tk.LEFT, padx=5)
        
        self.play_button = ttk.Button(basic_controls, text="▶", width=5, command=self.play_pause)
        self.play_button.pack(side=tk.LEFT, padx=5)
        
        stop_button = ttk.Button(basic_controls, text="⏹", width=5, command=self.stop)
        stop_button.pack(side=tk.LEFT, padx=5)
        
        next_button = ttk.Button(basic_controls, text="⏭", width=5, command=self.play_next)
        next_button.pack(side=tk.LEFT, padx=5)
        
        # Control de volumen
        volume_frame = ttk.Frame(control_frame)
        volume_frame.pack(fill=tk.X, padx=5, pady=5)
        
        volume_label = ttk.Label(volume_frame, text="Volumen:")
        volume_label.pack(side=tk.LEFT, padx=5)
        
        self.volume_var = tk.IntVar(value=70)
        volume_scale = ttk.Scale(volume_frame, from_=0, to=100, orient=tk.HORIZONTAL,
                               variable=self.volume_var, command=self.change_volume)
        volume_scale.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        
        self.mute_var = tk.BooleanVar(value=False)
        mute_check = ttk.Checkbutton(volume_frame, text="Silencio", variable=self.mute_var,
                                    command=self.toggle_mute)
        mute_check.pack(side=tk.LEFT, padx=5)
        
        # Carpeta de descargas
        downloads_frame = ttk.LabelFrame(self, text="Carpeta de descargas")
        downloads_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.downloads_path_var = tk.StringVar(value=os.path.expanduser("~/Downloads"))
        path_entry = ttk.Entry(downloads_frame, textvariable=self.downloads_path_var, width=50)
        path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, pady=5)
        
        browse_button = ttk.Button(downloads_frame, text="Explorar", 
                                 command=self.browse_downloads_folder)
        browse_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        refresh_button = ttk.Button(downloads_frame, text="Actualizar",
                                  command=self.refresh_from_downloads)
        refresh_button.pack(side=tk.LEFT, padx=5, pady=5)
        
        # Inicializar lista con archivos de la carpeta de descargas
        self.refresh_from_downloads()
        
        # Iniciar un temporizador para actualizar el estado del reproductor
        self.update_player_status()
    
    def add_files(self):
        files = filedialog.askopenfilenames(
            title="Seleccionar archivos multimedia",
            filetypes=[
                ("Archivos multimedia", "*.mp3 *.mp4 *.wav *.avi *.mkv *.webm *.m4a *.opus *.flac"),
                ("Archivos de audio", "*.mp3 *.wav *.m4a *.opus *.flac"),
                ("Archivos de video", "*.mp4 *.avi *.mkv *.webm"),
                ("Todos los archivos", "*.*")
            ]
        )
        if files:
            for file in files:
                if file not in self.playlist:
                    self.playlist.append(file)
                    self.playlist_box.insert(tk.END, os.path.basename(file))
    
    def remove_selected(self):
        selected_index = self.playlist_box.curselection()
        if selected_index:
            index = selected_index[0]
            self.playlist_box.delete(index)
            del self.playlist[index]
            
            # Si eliminamos la pista actual, detenemos la reproducción
            if index == self.current_index and self.is_playing:
                self.stop()
    
    def clear_playlist(self):
        self.stop()
        self.playlist_box.delete(0, tk.END)
        self.playlist = []
        self.current_index = 0
    
    def browse_downloads_folder(self):
        folder = filedialog.askdirectory(
            title="Seleccionar carpeta de descargas",
            initialdir=self.downloads_path_var.get()
        )
        if folder:
            self.downloads_path_var.set(folder)
            self.refresh_from_downloads()
    
    def refresh_from_downloads(self):
        """Actualiza la lista de reproducción con los archivos multimedia de la carpeta de descargas"""
        downloads_folder = self.downloads_path_var.get()
        if not os.path.exists(downloads_folder):
            return
        
        # Limpiar la lista actual
        self.clear_playlist()
        
        # Buscar archivos multimedia en la carpeta
        media_extensions = ['.mp3', '.mp4', '.wav', '.avi', '.mkv', '.webm', '.m4a', '.opus', '.flac']
        for file in os.listdir(downloads_folder):
            file_path = os.path.join(downloads_folder, file)
            if os.path.isfile(file_path) and os.path.splitext(file)[1].lower() in media_extensions:
                self.playlist.append(file_path)
                self.playlist_box.insert(tk.END, file)
        
        # También buscar en el escritorio (lugar común para descargas)
        desktop_path = os.path.expanduser("~/Desktop")
        if os.path.exists(desktop_path) and desktop_path != downloads_folder:
            for file in os.listdir(desktop_path):
                file_path = os.path.join(desktop_path, file)
                if os.path.isfile(file_path) and os.path.splitext(file)[1].lower() in media_extensions:
                    self.playlist.append(file_path)
                    self.playlist_box.insert(tk.END, file)
    
    def play_selected(self, event=None):
        selected_index = self.playlist_box.curselection()
        if selected_index:
            index = selected_index[0]
            self.current_index = index
            self.play_file(self.playlist[index])
    
    def play_file(self, file_path):
        self.stop()  # Detener cualquier reproducción actual
        
        file_ext = os.path.splitext(file_path)[1].lower()
        
        # Archivos de audio
        if file_ext in ['.mp3', '.wav', '.m4a', '.opus', '.flac']:
            if pygame_available:
                try:
                    pygame.mixer.music.load(file_path)
                    pygame.mixer.music.set_volume(self.volume_var.get() / 100)
                    pygame.mixer.music.play()
                    self.current_audio = file_path
                    self.current_video = None
                    self.is_playing = True
                    self.play_button.config(text="⏸")
                    self.now_playing_var.set(f"▶ {os.path.basename(file_path)}")
                except Exception as e:
                    messagebox.showerror("Error de reproducción", str(e))
                    self.is_playing = False
            else:
                messagebox.showwarning("Pygame no disponible", 
                                      "Para reproducir audio instala pygame: pip install pygame")
        
        # Archivos de video
        elif file_ext in ['.mp4', '.avi', '.mkv', '.webm']:
            if vlc_available and self.vlc_player:
                try:
                    media = self.vlc_instance.media_new(file_path)
                    self.vlc_player.set_media(media)
                    self.vlc_player.play()
                    self.current_video = file_path
                    self.current_audio = None
                    self.is_playing = True
                    self.play_button.config(text="⏸")
                    self.now_playing_var.set(f"▶ {os.path.basename(file_path)}")
                except Exception as e:
                    messagebox.showerror("Error de reproducción", str(e))
                    self.is_playing = False
            else:
                messagebox.showwarning("VLC no disponible", 
                                     "Para reproducir video instala python-vlc: pip install python-vlc")
        else:
            messagebox.showwarning("Formato no soportado", 
                                 f"El formato {file_ext} no es compatible con el reproductor.")
    
    def play_pause(self):
        if not self.playlist:
            messagebox.showinfo("Lista vacía", "Añade archivos a la lista de reproducción primero.")
            return
        
        if not self.is_playing:
            # Si no hay reproducción en curso, pero hay una lista, reproducir el elemento actual
            if self.current_index < len(self.playlist):
                self.play_file(self.playlist[self.current_index])
        else:
            # Si hay reproducción, pausar/reanudar
            if self.current_audio and pygame_available:
                if pygame.mixer.music.get_busy():
                    pygame.mixer.music.pause()
                    self.play_button.config(text="▶")
                else:
                    pygame.mixer.music.unpause()
                    self.play_button.config(text="⏸")
            
            if self.current_video and vlc_available and self.vlc_player:
                if self.vlc_player.is_playing():
                    self.vlc_player.pause()
                    self.play_button.config(text="▶")
                else:
                    self.vlc_player.play()
                    self.play_button.config(text="⏸")
    
    def stop(self):
        self.is_playing = False
        self.play_button.config(text="▶")
        self.now_playing_var.set("No hay reproducción en curso")
        
        if self.current_audio and pygame_available:
            pygame.mixer.music.stop()
            self.current_audio = None
        
        if self.current_video and vlc_available and self.vlc_player:
            self.vlc_player.stop()
            self.current_video = None
    
    def play_next(self):
        if not self.playlist:
            return
        
        self.current_index = (self.current_index + 1) % len(self.playlist)
        self.play_file(self.playlist[self.current_index])
        # Seleccionar en la lista
        self.playlist_box.selection_clear(0, tk.END)
        self.playlist_box.selection_set(self.current_index)
        self.playlist_box.see(self.current_index)
    
    def play_previous(self):
        if not self.playlist:
            return
        
        self.current_index = (self.current_index - 1) % len(self.playlist)
        self.play_file(self.playlist[self.current_index])
        # Seleccionar en la lista
        self.playlist_box.selection_clear(0, tk.END)
        self.playlist_box.selection_set(self.current_index)
        self.playlist_box.see(self.current_index)
    
    def change_volume(self, value=None):
        volume = self.volume_var.get() / 100
        
        if pygame_available:
            pygame.mixer.music.set_volume(volume)
        
        if vlc_available and self.vlc_player:
            self.vlc_player.audio_set_volume(int(volume * 100))
    
    def toggle_mute(self):
        if self.mute_var.get():
            if pygame_available:
                pygame.mixer.music.set_volume(0)
            if vlc_available and self.vlc_player:
                self.vlc_player.audio_set_volume(0)
        else:
            self.change_volume()
    
    def update_player_status(self):
        """Actualiza el estado del reproductor periódicamente"""
        if self.is_playing:
            # Verificar si el audio ha terminado
            if self.current_audio and pygame_available:
                if not pygame.mixer.music.get_busy():
                    self.play_next()
            
            # Verificar si el video ha terminado (más complejo con VLC)
            if self.current_video and vlc_available and self.vlc_player:
                if self.vlc_player.get_state() == vlc.State.Ended:
                    self.play_next()
        
        # Actualizar cada 500ms
        self.after(500, self.update_player_status)
    
    def play_file_by_name(self, filename):
        """Busca un archivo por nombre y lo reproduce"""
        # Primero intentar una búsqueda exacta
        for i, file_path in enumerate(self.playlist):
            if os.path.basename(file_path).lower() == filename.lower():
                self.current_index = i
                self.play_file(file_path)
                self.playlist_box.selection_clear(0, tk.END)
                self.playlist_box.selection_set(self.current_index)
                self.playlist_box.see(self.current_index)
                logger.info(f"Reproduciendo archivo exacto: {filename}")
                return True
        
        # Si no encontró el archivo exacto, buscar coincidencias parciales
        for i, file_path in enumerate(self.playlist):
            if filename.lower() in os.path.basename(file_path).lower():
                self.current_index = i
                self.play_file(file_path)
                self.playlist_box.selection_clear(0, tk.END)
                self.playlist_box.selection_set(self.current_index)
                self.playlist_box.see(self.current_index)
                logger.info(f"Reproduciendo coincidencia parcial: {os.path.basename(file_path)}")
                return True
        
        # Si aún no se encuentra, buscar nuevos archivos
        logger.info(f"Archivo {filename} no encontrado, actualizando lista...")
        self.refresh_from_downloads()
        
        # Intentar una vez más con la lista actualizada
        for i, file_path in enumerate(self.playlist):
            if filename.lower() in os.path.basename(file_path).lower():
                self.current_index = i
                self.play_file(file_path)
                self.playlist_box.selection_clear(0, tk.END)
                self.playlist_box.selection_set(self.current_index)
                self.playlist_box.see(self.current_index)
                logger.info(f"Reproduciendo archivo tras actualización: {os.path.basename(file_path)}")
                return True
        
        logger.warning(f"No se pudo encontrar el archivo: {filename}")
        return False

###############################################################################
#                    DESCARGADOR DE VIDEOS/MÚSICA
###############################################################################
class VideoDownloaderFrame(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent, padding="20")
        self.parent = parent
        
        # Configure style
        self.style = ttk.Style()
        self.style.configure("TButton", font=("Arial", 12))
        self.style.configure("TLabel", font=("Arial", 12))
        self.style.configure("Header.TLabel", font=("Arial", 16, "bold"))
        
        # Header
        header_frame = ttk.Frame(self)
        header_frame.pack(fill=tk.X, pady=5)
        
        header_label = ttk.Label(header_frame, text="Descargador de Contenido Multimedia", 
                                style="Header.TLabel")
        header_label.pack(pady=10)
        
        # URL input
        url_frame = ttk.Frame(self)
        url_frame.pack(fill=tk.X, pady=10)
        
        url_label = ttk.Label(url_frame, text="URL Video/Playlist:")
        url_label.pack(side=tk.LEFT, padx=5)
        
        self.url_entry = ttk.Entry(url_frame, width=50, font=("Arial", 12))
        self.url_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.url_entry.focus()
        
        # Playlist download checkbox
        self.playlist_var = tk.BooleanVar(value=False)
        playlist_check = ttk.Checkbutton(url_frame, text="Descargar lista completa", variable=self.playlist_var)
        playlist_check.pack(side=tk.RIGHT, padx=5)
        
        # Download location
        location_frame = ttk.Frame(self)
        location_frame.pack(fill=tk.X, pady=10)
        
        location_label = ttk.Label(location_frame, text="Guardar en:")
        location_label.pack(side=tk.LEFT, padx=5)
        
        self.location_entry = ttk.Entry(location_frame, width=40, font=("Arial", 12))
        self.location_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.location_entry.insert(0, os.path.expanduser("~/Desktop"))
        
        browse_button = ttk.Button(location_frame, text="Explorar", command=self.browse_location)
        browse_button.pack(side=tk.RIGHT, padx=5)
        
        # Format selection
        format_frame = ttk.Frame(self)
        format_frame.pack(fill=tk.X, pady=10)
        
        # Format type selection (Video or Audio)
        self.format_type = tk.StringVar(value="video")
        
        format_type_frame = ttk.LabelFrame(format_frame, text="Tipo de Descarga")
        format_type_frame.pack(fill=tk.X, pady=5)
        
        video_radio = ttk.Radiobutton(format_type_frame, text="Video", variable=self.format_type, 
                                     value="video", command=self.update_format_options)
        video_radio.pack(side=tk.LEFT, padx=20, pady=5)
        
        audio_radio = ttk.Radiobutton(format_type_frame, text="Solo Audio", variable=self.format_type, 
                                     value="audio", command=self.update_format_options)
        audio_radio.pack(side=tk.LEFT, padx=20, pady=5)
        
        # Video/Audio format options
        options_frame = ttk.LabelFrame(self, text="Opciones de Formato")
        options_frame.pack(fill=tk.X, pady=10)
        
        # Quality selection
        quality_frame = ttk.Frame(options_frame)
        quality_frame.pack(fill=tk.X, pady=5, padx=10)
        
        quality_label = ttk.Label(quality_frame, text="Calidad:")
        quality_label.pack(side=tk.LEFT, padx=5)
        
        self.quality_var = tk.StringVar(value="best")
        self.quality_combobox = ttk.Combobox(quality_frame, textvariable=self.quality_var, width=25)
        self.quality_combobox.pack(side=tk.LEFT, padx=5, expand=True)
        
        # Container/Format selection
        container_frame = ttk.Frame(options_frame)
        container_frame.pack(fill=tk.X, pady=5, padx=10)
        
        self.format_label = ttk.Label(container_frame, text="Formato:")
        self.format_label.pack(side=tk.LEFT, padx=5)
        
        self.container_var = tk.StringVar(value="mp4")
        
        self.container_combobox = ttk.Combobox(container_frame, textvariable=self.container_var, width=10)
        self.container_combobox.pack(side=tk.LEFT, padx=5)
        
        # Speed option
        speed_frame = ttk.Frame(options_frame)
        speed_frame.pack(fill=tk.X, pady=5, padx=10)
        
        speed_label = ttk.Label(speed_frame, text="Velocidad de conversión:")
        speed_label.pack(side=tk.LEFT, padx=5)
        
        self.speed_var = tk.StringVar(value="fast")
        speed_combobox = ttk.Combobox(speed_frame, textvariable=self.speed_var, 
                                     values=["slow", "medium", "fast", "ultrafast"], width=10)
        speed_combobox.pack(side=tk.LEFT, padx=5)
        
        # Initialize format options
        self.update_format_options()
        
        # Buttons
        buttons_frame = ttk.Frame(self)
        buttons_frame.pack(fill=tk.X, pady=20)
        
        self.download_button = ttk.Button(buttons_frame, text="Descargar", command=self.start_download)
        self.download_button.pack(side=tk.LEFT, padx=5)
        
        self.cancel_button = ttk.Button(buttons_frame, text="Cancelar", command=self.cancel_download, state=tk.DISABLED)
        self.cancel_button.pack(side=tk.LEFT, padx=5)
        
        self.info_button = ttk.Button(buttons_frame, text="Obtener Info del Video", command=self.get_video_info)
        self.info_button.pack(side=tk.LEFT, padx=5)
        
        # Progress frame
        progress_frame = ttk.Frame(self)
        progress_frame.pack(fill=tk.X, pady=10)
        
        self.progress_label = ttk.Label(progress_frame, text="")
        self.progress_label.pack(side=tk.TOP, anchor=tk.W, pady=5)
        
        self.progress_bar = ttk.Progressbar(progress_frame, orient=tk.HORIZONTAL, length=100, mode='determinate')
        self.progress_bar.pack(fill=tk.X, pady=5)
        
        # Status log
        log_frame = ttk.Frame(self)
        log_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        log_label = ttk.Label(log_frame, text="Estado:")
        log_label.pack(anchor=tk.W)
        
        log_container = ttk.Frame(log_frame)
        log_container.pack(fill=tk.BOTH, expand=True)
        
        self.log_text = tk.Text(log_container, height=12, width=50, font=("Consolas", 10))
        self.log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.log_text.config(state=tk.DISABLED)
        
        # Scrollbar for log
        scrollbar = ttk.Scrollbar(log_container, command=self.log_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text.config(yscrollcommand=scrollbar.set)
        
        # Download attributes
        self.downloading = False
        self.ydl = None
        self.download_thread = None
        self.video_info = None
        
        # Check for FFmpeg
        if not self.check_ffmpeg():
            self.log_message("ADVERTENCIA: FFmpeg no encontrado. Instale FFmpeg para todas las funcionalidades.")
            messagebox.showwarning("FFmpeg No Encontrado", 
                "FFmpeg no se encuentra en su sistema. Instale FFmpeg para una correcta conversión de audio y video.")
        
    def check_ffmpeg(self):
        """Verifica si FFmpeg está instalado en el sistema"""
        try:
            with open(os.devnull, "w") as devnull:
                subprocess.call(["ffmpeg", "-version"], stdout=devnull, stderr=devnull)
            return True
        except (subprocess.SubprocessError, FileNotFoundError):
            return False
        
    def update_format_options(self):
        if self.format_type.get() == "video":
            # Video quality options
            video_qualities = [
                "best", 
                "bestvideo[height>=2160]+bestaudio/best[height>=2160]", # 4K
                "bestvideo[height>=1440]+bestaudio/best[height>=1440]", # 2K
                "bestvideo[height>=1080]+bestaudio/best[height>=1080]", # 1080p
                "bestvideo[height>=720]+bestaudio/best[height>=720]",  # 720p
                "bestvideo[height>=480]+bestaudio/best[height>=480]",  # 480p
                "bestvideo[height>=360]+bestaudio/best[height>=360]"   # 360p
            ]
            self.quality_combobox['values'] = video_qualities
            self.quality_var.set("best")
            
            # Video container options
            video_formats = ["mp4", "mkv", "webm", "avi", "mov", "flv"]
            self.container_combobox['values'] = video_formats
            self.container_var.set("mp4")
            
            self.format_label.config(text="Formato de Video:")
        else:
            # Audio quality options
            audio_qualities = [
                "bestaudio", 
                "bestaudio[abr>=256]", # High quality
                "bestaudio[abr>=192]", # Medium quality
                "bestaudio[abr>=128]", # Standard quality
                "bestaudio[abr>=96]"   # Low quality
            ]
            self.quality_combobox['values'] = audio_qualities
            self.quality_var.set("bestaudio")
            
            # Audio container options
            audio_formats = ["mp3", "m4a", "opus", "wav", "aac", "flac"]
            self.container_combobox['values'] = audio_formats
            self.container_var.set("mp3")
            
            self.format_label.config(text="Formato de Audio:")
        
    def browse_location(self):
        directory = filedialog.askdirectory(initialdir=self.location_entry.get())
        if directory:
            self.location_entry.delete(0, tk.END)
            self.location_entry.insert(0, directory)
    
    def log_message(self, message):
        self.log_text.config(state=tk.NORMAL)
        self.log_text.insert(tk.END, f"{message}\n")
        self.log_text.see(tk.END)
        self.log_text.config(state=tk.DISABLED)
        logger.info(message)
        
    def progress_hook(self, d):
        if d['status'] == 'downloading':
            try:
                percent = d.get('_percent_str', 'N/A')
                speed = d.get('_speed_str', 'N/A')
                eta = d.get('_eta_str', 'N/A')
                downloaded = d.get('downloaded_bytes', 0)
                total = d.get('total_bytes', 0) or d.get('total_bytes_estimate', 0)
                
                # Crear barra de progreso visual en la terminal
                if total > 0:
                    bar_length = 40
                    progress = downloaded / total
                    block = int(round(bar_length * progress))
                    progress_bar = "█" * block + "░" * (bar_length - block)
                    print(f"\rProgreso: |{progress_bar}| {percent} @ {speed}, ETA: {eta}", end="")
                    sys.stdout.flush()
                
                progress_text = f"Descargando... {percent} a {speed}, Tiempo restante: {eta}"
                self.after(0, lambda: self.update_progress(progress_text, downloaded, total))
            except Exception as e:
                logger.error(f"Error en progress_hook: {str(e)}")
        elif d['status'] == 'finished':
            print("\nDescarga completa. Procesando archivo...")
            self.after(0, lambda: self.log_message("Descarga completa. Procesando..."))
    
    def update_progress(self, text, current, total):
        self.progress_label.config(text=text)
        if total > 0:
            percent = (current / total) * 100
            self.progress_bar['value'] = percent
    
    def get_video_info(self):
        url = self.url_entry.get().strip()
        if not url:
            messagebox.showerror("Error", "Por favor ingresa una URL")
            return
            
        self.progress_label.config(text="Obteniendo información del video...")
        self.log_message(f"Obteniendo información de: {url}")
        
        self.info_button.config(state=tk.DISABLED)
        self.download_button.config(state=tk.DISABLED)
        
        threading.Thread(target=self.fetch_video_info, args=(url,), daemon=True).start()
        
    def fetch_video_info(self, url):
        try:
            url = clean_youtube_url(url)  # Limpia la URL
            self.after(0, lambda: self.log_message(f"URL procesada: {url}"))
            
            ydl_opts = {
                'quiet': False,
                'no_warnings': False,
                'ignoreerrors': True,
                'geo_bypass': True,
                'nocheckcertificate': True
            }
            if not self.playlist_var.get():
                ydl_opts['noplaylist'] = True
            
            logger.info(f"Obteniendo info del video con yt-dlp: {url}")
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                try:
                    info_dict = ydl.extract_info(url, download=False)
                    if info_dict is None:
                        raise Exception("No se pudo obtener información del video")
                    
                    # Guardar info para uso posterior
                    self.video_info = info_dict
                    
                    self.after(0, lambda: self.show_video_info(info_dict))
                except Exception as e:
                    self.after(0, lambda: self.log_message(f"Error al extraer información: {str(e)}"))
                    self.after(0, lambda: self.reset_buttons())
        except Exception as e:
            logger.error(f"Error al obtener información del video: {str(e)}")
            self.after(0, lambda: self.log_message(f"Error al obtener información: {str(e)}"))
            self.after(0, lambda: self.reset_buttons())
            
    def show_video_info(self, info):
        if info:
            if 'entries' in info:
                playlist_title = info.get('title', 'Playlist')
                entries = info.get('entries', [])
                
                if entries:
                    self.log_message(f"Playlist: {playlist_title} - {len(entries)} videos encontrados")
                    for idx, entry in enumerate(entries, start=1):
                        if entry:
                            title = entry.get('title', f"Video {idx}")
                            self.log_message(f"{idx}. {title}")
                else:
                    self.log_message(f"Playlist: {playlist_title} - Sin videos o info restringida")
            else:
                title = info.get('title', 'Título desconocido')
                duration = info.get('duration', 0)
                minutes, seconds = divmod(duration, 60)
                self.log_message(f"Título: {title}")
                self.log_message(f"Duración: {minutes}:{seconds:02d}")
                
                # Información sobre el canal
                if 'channel' in info:
                    self.log_message(f"Canal: {info['channel']}")
                
                # Información sobre formatos
                video_formats = set()
                audio_formats = set()
                max_height = 0
                for f in info.get('formats', []):
                    if f.get('height'):
                        video_formats.add(f"{f.get('height')}p")
                        if f.get('height') > max_height:
                            max_height = f.get('height')
                    elif f.get('format_note') == 'audio only':
                        acodec = f.get('acodec', 'unknown')
                        if acodec != 'none':
                            audio_formats.add(f"{acodec} ({f.get('ext', 'unknown')})")
                
                if video_formats:
                    sorted_video = sorted([int(f.replace('p', '')) for f in video_formats if 'p' in f], reverse=True)
                    self.log_message(f"Calidades de video disponibles: {', '.join([f'{q}p' for q in sorted_video])}")
                if audio_formats:
                    self.log_message(f"Formatos de audio disponibles: {', '.join(audio_formats)}")
                
                # Destacar calidades especiales
                if max_height >= 2160:
                    self.log_message("¡Calidad 4K disponible!")
                elif max_height >= 1440:
                    self.log_message("¡Calidad 2K disponible!")
                elif max_height >= 1080:
                    self.log_message("¡Calidad Full HD disponible!")
        
        self.reset_buttons()
            
    def reset_buttons(self):
        self.info_button.config(state=tk.NORMAL)
        self.download_button.config(state=tk.NORMAL)
        self.progress_label.config(text="Listo para descargar")
        
    def start_download(self):
        url = self.url_entry.get().strip()
        if not url:
            messagebox.showerror("Error", "Por favor ingresa una URL")
            return
        
        # Limpiar y normalizar la URL
        url = clean_youtube_url(url)
        self.log_message(f"URL procesada: {url}")
        
        save_path = self.location_entry.get().strip()
        if not os.path.isdir(save_path):
            try:
                os.makedirs(save_path)
            except Exception as e:
                messagebox.showerror("Error", f"No se pudo crear el directorio: {str(e)}")
                return
        
        quality_option = self.quality_var.get()
        container_format = self.container_var.get()
        speed_preset = self.speed_var.get()
        download_playlist = self.playlist_var.get()
        is_audio = self.format_type.get() == "audio"
        
        self.downloading = True
        self.download_button.config(state=tk.DISABLED)
        self.info_button.config(state=tk.DISABLED)
        self.cancel_button.config(state=tk.NORMAL)
        self.progress_bar['value'] = 0
        self.progress_label.config(text="Preparando descarga...")
        
        # Mostrar información clara en la terminal también
        print(f"\n[DESCARGA] Iniciando descarga de {'AUDIO' if is_audio else 'VIDEO'} desde: {url}")
        print(f"[DESCARGA] Guardando en: {save_path}")
        print(f"[DESCARGA] Formato: {container_format}, Calidad: {quality_option}")
        if download_playlist:
            print(f"[DESCARGA] MODO PLAYLIST ACTIVADO - Se descargarán todos los videos de la lista")
        
        self.log_message(f"Iniciando descarga desde: {url}")
        if download_playlist:
            self.log_message("Modo Playlist activado: se descargarán TODOS los videos de la lista.")
        else:
            self.log_message(f"Calidad seleccionada: {quality_option}, Formato: {container_format}, Velocidad: {speed_preset}")
        
        temp_dir = os.path.join(save_path, f".temp_{int(time.time())}")
        os.makedirs(temp_dir, exist_ok=True)
        
        self.download_thread = threading.Thread(
            target=self.perform_download, 
            args=(url, save_path, temp_dir, quality_option, container_format, speed_preset, download_playlist)
        )
        self.download_thread.daemon = True
        self.download_thread.start()
    
    def perform_download(self, url, save_path, temp_dir, quality_option, container_format, speed_preset, download_playlist):
        try:
            is_audio_only = self.format_type.get() == "audio"
            output_filename = None
            
            ffmpeg_presets = {
                "slow": "medium",
                "medium": "fast",
                "fast": "veryfast",
                "ultrafast": "ultrafast"
            }
            ffmpeg_preset = ffmpeg_presets.get(speed_preset, "fast")
            
            try:
                with yt_dlp.YoutubeDL({'quiet': True, 'ignoreerrors': True, 'geo_bypass': True}) as ydl:
                    info_dict = ydl.extract_info(url, download=False)
                    if info_dict is None:
                        raise Exception("No se pudo obtener información del video")
                    if 'entries' in info_dict:
                        video_title = info_dict.get('title', 'playlist')
                    else:
                        video_title = info_dict.get('title', 'video')
                    safe_title = "".join([c if c.isalnum() or c in ' ._-' else '_' for c in video_title])
            except Exception as info_error:
                self.after(0, lambda: self.log_message(f"Error al obtener información: {str(info_error)}"))
                # Usar un título genérico si no se puede obtener el real
                import uuid
                safe_title = f"video_{uuid.uuid4().hex[:8]}"
            
            # Si es playlist, incluir el índice de cada video en el nombre de archivo
            if download_playlist:
                temp_output = os.path.join(temp_dir, f"{safe_title}_%(playlist_index)s.%(ext)s")
            else:
                temp_output = os.path.join(temp_dir, f"{safe_title}.%(ext)s")
            
            ydl_opts = {
                'format': quality_option,
                'outtmpl': temp_output,
                'progress_hooks': [self.progress_hook],
                'quiet': False,
                'no_warnings': False,
                'verbose': True,
                'ignoreerrors': True,
                'geo_bypass': True,
                'nocheckcertificate': True
            }
            if not download_playlist:
                ydl_opts['noplaylist'] = True
            
            if is_audio_only:
                self.after(0, lambda: self.log_message("Descargando audio..."))
                audio_codec_map = {
                    'mp3': 'libmp3lame',
                    'm4a': 'aac',
                    'opus': 'libopus',
                    'wav': 'pcm_s16le',
                    'aac': 'aac',
                    'flac': 'flac'
                }
                audio_codec = audio_codec_map.get(container_format, 'aac')
                ydl_opts['format'] = "bestaudio/best"
                ydl_opts['postprocessors'] = [{
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': container_format,
                    'preferredquality': '192',
                }]
                ydl_opts['postprocessor_args'] = [
                    '-c:a', audio_codec,
                ]
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                self.ydl = ydl
                ydl.download([url])
            
            if is_audio_only:
                audio_files = glob.glob(os.path.join(temp_dir, f"*.{container_format}"))
                if audio_files:
                    # Si es playlist, mover todos los archivos descargados
                    if download_playlist:
                        for file in audio_files:
                            dest_file = os.path.join(save_path, os.path.basename(file))
                            if os.path.exists(dest_file):
                                os.remove(dest_file)
                            os.rename(file, dest_file)
                        output_filename = f"{safe_title} (Playlist)"
                    else:
                        temp_file = audio_files[0]
                        output_filename = os.path.join(save_path, os.path.basename(temp_file))
                        if os.path.exists(output_filename):
                            os.remove(output_filename)
                        os.rename(temp_file, output_filename)
                        self.after(0, lambda: self.log_message(f"Audio guardado como: {os.path.basename(output_filename)}"))
                else:
                    # Buscar cualquier archivo de audio que pueda haber sido generado
                    any_audio = glob.glob(os.path.join(temp_dir, "*.mp3")) + \
                                glob.glob(os.path.join(temp_dir, "*.m4a")) + \
                                glob.glob(os.path.join(temp_dir, "*.opus")) + \
                                glob.glob(os.path.join(temp_dir, "*.wav")) + \
                                glob.glob(os.path.join(temp_dir, "*.aac")) + \
                                glob.glob(os.path.join(temp_dir, "*.flac"))
                    if any_audio:
                        self.after(0, lambda: self.log_message(f"Encontrados otros formatos de audio: {len(any_audio)} archivos"))
                        for file in any_audio:
                            dest_file = os.path.join(save_path, os.path.basename(file))
                            if os.path.exists(dest_file):
                                os.remove(dest_file)
                            os.rename(file, dest_file)
                            self.after(0, lambda: self.log_message(f"Audio alternativo guardado como: {os.path.basename(dest_file)}"))
                        output_filename = any_audio[0]
                    else:
                        raise Exception("No se encontró el archivo de audio descargado")
            else:
                video_files = glob.glob(os.path.join(temp_dir, "*.*"))
                video_files = [f for f in video_files if not f.endswith(('.part', '.ytdl'))]
                if not video_files:
                    # Listar todos los archivos en el directorio para diagnóstico
                    all_files = os.listdir(temp_dir) if os.path.exists(temp_dir) else []
                    self.after(0, lambda: self.log_message(f"Archivos en directorio temporal: {all_files}"))
                    raise Exception("Fallo al descargar el video")
                
                if download_playlist:
                    # Para playlists, se asume que yt-dlp ya generó archivos con el índice en el nombre
                    for file in video_files:
                        dest_file = os.path.join(save_path, os.path.basename(file))
                        if os.path.exists(dest_file):
                            os.remove(dest_file)
                        os.rename(file, dest_file)
                        self.after(0, lambda: self.log_message(f"Video guardado como: {os.path.basename(dest_file)}"))
                    output_filename = f"{safe_title} (Playlist)"
                else:
                    source_file = video_files[0]
                    ext = os.path.splitext(source_file)[1][1:]
                    final_filename = f"{safe_title}.{container_format}"
                    output_filename = os.path.join(save_path, final_filename)
                    
                    self.after(0, lambda: self.log_message(f"Archivo fuente: {os.path.basename(source_file)}"))
                    
                    if ext != container_format:
                        self.after(0, lambda: self.log_message(f"Convirtiendo a formato {container_format}..."))
                        self.after(0, lambda: self.update_progress("Convirtiendo formato de video...", 50, 100))
                        
                        cmd = [
                            'ffmpeg', '-y', '-i', source_file,
                            '-c:v', 'libx264', '-preset', ffmpeg_preset,
                            '-c:a', 'aac', '-b:a', '192k',
                            output_filename
                        ]
                        
                        # Imprimir el comando para diagnóstico
                        cmd_str = " ".join(cmd)
                        self.after(0, lambda: self.log_message(f"Comando FFmpeg: {cmd_str}"))
                        
                        try:
                            print(f"\n[CONVIRTIENDO] Ejecutando FFmpeg para convertir formato...")
                            process = subprocess.Popen(
                                cmd, 
                                stdout=subprocess.PIPE, 
                                stderr=subprocess.PIPE,
                                universal_newlines=True
                            )
                            
                            # Capturar y mostrar salida de FFmpeg
                            for line in process.stderr:
                                if "time=" in line and "bitrate=" in line:
                                    print(f"\r[CONVIRTIENDO] {line.strip()}", end="")
                                    sys.stdout.flush()
                            
                            # Esperar a que termine
                            result = process.wait()
                            print("\n[CONVERSIÓN] Proceso de FFmpeg finalizado")
                        except Exception as e:
                            self.after(0, lambda: self.log_message(f"Error durante la conversión: {str(e)}"))
                            result = -1
                        
                        if not os.path.exists(output_filename) or os.path.getsize(output_filename) == 0:
                            # Si la conversión falló, intentamos copiar el archivo original
                            self.after(0, lambda: self.log_message("Conversión fallida. Copiando archivo original..."))
                            fallback_output = os.path.join(save_path, os.path.basename(source_file))
                            if os.path.exists(fallback_output):
                                os.remove(fallback_output)
                            os.rename(source_file, fallback_output)
                            output_filename = fallback_output
                            self.after(0, lambda: self.log_message(f"Archivo guardado sin convertir como: {os.path.basename(fallback_output)}"))
                    else:
                        # Solo mover el archivo
                        if os.path.exists(output_filename):
                            os.remove(output_filename)
                        os.rename(source_file, output_filename)
                        self.after(0, lambda: self.log_message(f"Archivo guardado como: {os.path.basename(output_filename)}"))
            
            try:
                for file in os.listdir(temp_dir):
                    file_path = os.path.join(temp_dir, file)
                    if os.path.isfile(file_path):
                        os.unlink(file_path)
                os.rmdir(temp_dir)
            except Exception as e:
                self.after(0, lambda: self.log_message(f"Advertencia de limpieza: {str(e)}"))
            
            self.after(0, lambda: self.download_complete(True, output_filename))
        
        except Exception as e:
            self.after(0, lambda: self.log_message(f"Error durante la descarga: {str(e)}"))
            self.after(0, lambda: self.download_complete(False, str(e)))
    
    def download_complete(self, success, message):
        self.downloading = False
        self.ydl = None
        
        self.download_button.config(state=tk.NORMAL)
        self.info_button.config(state=tk.NORMAL)
        self.cancel_button.config(state=tk.DISABLED)
        
        if success:
            self.progress_label.config(text="¡Descarga completada exitosamente!")
            self.log_message(f"Descarga completada: {os.path.basename(message) if os.path.exists(message) else message}")
            resp = messagebox.askyesno("Descarga Completa", "¡Descarga completada! ¿Abrir carpeta contenedora?")
            if resp:
                self.open_folder(os.path.dirname(message) if os.path.exists(message) else self.location_entry.get())
        else:
            self.progress_label.config(text="Fallo en la descarga")
            self.log_message(f"Error durante la descarga: {message}")
            messagebox.showerror("Error de Descarga", f"Fallo al descargar: {message}")
    
    def cancel_download(self):
        if self.downloading:
            self.log_message("Cancelando descarga...")
            self.downloading = False
            if self.ydl:
                if self.download_thread and self.download_thread.is_alive():
                    pass
            self.download_button.config(state=tk.NORMAL)
            self.info_button.config(state=tk.NORMAL)
            self.cancel_button.config(state=tk.DISABLED)
            self.progress_label.config(text="Descarga cancelada")
    
    def open_folder(self, folder_path):
        try:
            if os.name == 'nt':
                os.startfile(folder_path)
            elif os.name == 'posix':
                subprocess.Popen(['xdg-open', folder_path])
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo abrir la carpeta: {str(e)}")
    
    # Método para descarga programática (para usar desde el chatbot)
    def download_from_url(self, url, is_audio=False, format_type="mp4"):
        """Inicia una descarga programáticamente desde el chatbot"""
        if not url:
            return False, "URL vacía"
        
        # En lugar de modificar widgets de tkinter, usamos la función de descarga directa
        return direct_download_media(url, is_audio, format_type)

###############################################################################
#                       GENERACIÓN DE IMÁGENES Y VIDEOS
###############################################################################
class MediaGenerationFrame(ttk.Frame):
    """Frame para generar imágenes y videos usando modelos de IA"""
    def __init__(self, parent):
        super().__init__(parent, padding="20")
        self.parent = parent
        
        # Configure style
        self.style = ttk.Style()
        self.style.configure("TButton", font=("Arial", 12))
        self.style.configure("TLabel", font=("Arial", 12))
        self.style.configure("Header.TLabel", font=("Arial", 16, "bold"))
        
        # Variables de control
        self.generating = False
        self.current_image = None
        self.current_video = None
        self.current_provider = None
        
        self.create_widgets()
    
    def create_widgets(self):
        # Header
        header_label = ttk.Label(self, text="Generación de Imágenes y Videos con IA", 
                               style="Header.TLabel")
        header_label.pack(pady=10)
        
        # Proveedor de IA
        provider_frame = ttk.LabelFrame(self, text="Proveedor de IA")
        provider_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.provider_var = tk.StringVar(value="openai")
        
        openai_radio = ttk.Radiobutton(provider_frame, text="OpenAI (DALL-E / Sora)", 
                                     variable=self.provider_var, value="openai")
        openai_radio.pack(side=tk.LEFT, padx=20, pady=5)
        
        google_radio = ttk.Radiobutton(provider_frame, text="Google (Imagen)", 
                                     variable=self.provider_var, value="gemini")
        google_radio.pack(side=tk.LEFT, padx=20, pady=5)
        
        claude_radio = ttk.Radiobutton(provider_frame, text="Claude (Descripción)", 
                                      variable=self.provider_var, value="anthropic")
        claude_radio.pack(side=tk.LEFT, padx=20, pady=5)
        
        # Tipo de generación
        type_frame = ttk.LabelFrame(self, text="Tipo de generación")
        type_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.generation_type = tk.StringVar(value="image")
        
        image_radio = ttk.Radiobutton(type_frame, text="Imagen", 
                                     variable=self.generation_type, value="image",
                                     command=self.update_options)
        image_radio.pack(side=tk.LEFT, padx=20, pady=5)
        
        video_radio = ttk.Radiobutton(type_frame, text="Video", 
                                     variable=self.generation_type, value="video",
                                     command=self.update_options)
        video_radio.pack(side=tk.LEFT, padx=20, pady=5)
        
        # Prompt y opciones
        prompt_frame = ttk.LabelFrame(self, text="Descripción")
        prompt_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        prompt_label = ttk.Label(prompt_frame, text="Describe lo que quieres generar:")
        prompt_label.pack(anchor=tk.W, padx=5, pady=5)
        
        self.prompt_text = tk.Text(prompt_frame, height=4, width=70, wrap=tk.WORD, font=("Arial", 11))
        self.prompt_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Opciones específicas
        options_frame = ttk.LabelFrame(self, text="Opciones")
        options_frame.pack(fill=tk.X, padx=10, pady=10)
        
        # Para imágenes
        self.image_options_frame = ttk.Frame(options_frame)
        self.image_options_frame.pack(fill=tk.X, padx=5, pady=5)
        
        size_label = ttk.Label(self.image_options_frame, text="Tamaño:")
        size_label.grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        
        self.size_var = tk.StringVar(value="1024x1024")
        size_combo = ttk.Combobox(self.image_options_frame, textvariable=self.size_var, width=12,
                               values=["256x256", "512x512", "1024x1024", "1024x1792", "1792x1024"])
        size_combo.grid(row=0, column=1, padx=5, pady=5)
        
        model_label = ttk.Label(self.image_options_frame, text="Modelo:")
        model_label.grid(row=0, column=2, padx=5, pady=5, sticky=tk.W)
        
        self.model_var = tk.StringVar(value="dall-e-3")
        model_combo = ttk.Combobox(self.image_options_frame, textvariable=self.model_var, width=12,
                                 values=["dall-e-2", "dall-e-3"])
        model_combo.grid(row=0, column=3, padx=5, pady=5)
        
        quality_label = ttk.Label(self.image_options_frame, text="Calidad:")
        quality_label.grid(row=1, column=0, padx=5, pady=5, sticky=tk.W)
        
        self.quality_var = tk.StringVar(value="standard")
        quality_combo = ttk.Combobox(self.image_options_frame, textvariable=self.quality_var, width=12,
                                   values=["standard", "hd"])
        quality_combo.grid(row=1, column=1, padx=5, pady=5)
        
        style_label = ttk.Label(self.image_options_frame, text="Estilo:")
        style_label.grid(row=1, column=2, padx=5, pady=5, sticky=tk.W)
        
        self.style_var = tk.StringVar(value="vivid")
        style_combo = ttk.Combobox(self.image_options_frame, textvariable=self.style_var, width=12,
                                 values=["vivid", "natural"])
        style_combo.grid(row=1, column=3, padx=5, pady=5)
        
        # Para videos
        self.video_options_frame = ttk.Frame(options_frame)
        
        duration_label = ttk.Label(self.video_options_frame, text="Duración (segs):")
        duration_label.grid(row=0, column=0, padx=5, pady=5, sticky=tk.W)
        
        self.duration_var = tk.IntVar(value=5)
        duration_spin = ttk.Spinbox(self.video_options_frame, from_=1, to=60, 
                                  textvariable=self.duration_var, width=5)
        duration_spin.grid(row=0, column=1, padx=5, pady=5)
        
        video_model_label = ttk.Label(self.video_options_frame, text="Modelo:")
        video_model_label.grid(row=0, column=2, padx=5, pady=5, sticky=tk.W)
        
        self.video_model_var = tk.StringVar(value="sora-1.0-turbo")
        video_model_combo = ttk.Combobox(self.video_options_frame, textvariable=self.video_model_var, 
                                       width=15, values=["sora-1.0-turbo"])
        video_model_combo.grid(row=0, column=3, padx=5, pady=5)
        
        video_quality_label = ttk.Label(self.video_options_frame, text="Calidad:")
        video_quality_label.grid(row=1, column=0, padx=5, pady=5, sticky=tk.W)
        
        self.video_quality_var = tk.StringVar(value="standard")
        video_quality_combo = ttk.Combobox(self.video_options_frame, textvariable=self.video_quality_var, 
                                         width=10, values=["standard", "hd"])
        video_quality_combo.grid(row=1, column=1, padx=5, pady=5)
        
        # Botones de acción
        buttons_frame = ttk.Frame(self)
        buttons_frame.pack(fill=tk.X, padx=10, pady=10)
        
        self.generate_button = ttk.Button(buttons_frame, text="Generar", 
                                        command=self.generate_media)
        self.generate_button.pack(side=tk.LEFT, padx=5)
        
        self.save_button = ttk.Button(buttons_frame, text="Guardar resultado", 
                                    command=self.save_media, state=tk.DISABLED)
        self.save_button.pack(side=tk.LEFT, padx=5)
        
        self.clear_button = ttk.Button(buttons_frame, text="Limpiar", 
                                     command=self.clear_result)
        self.clear_button.pack(side=tk.LEFT, padx=5)
        
        # Status frame
        status_frame = ttk.Frame(self)
        status_frame.pack(fill=tk.X, padx=10, pady=5)
        
        self.status_label = ttk.Label(status_frame, text="")
        self.status_label.pack(fill=tk.X)
        
        self.progress_bar = ttk.Progressbar(status_frame, mode="indeterminate", length=100)
        self.progress_bar.pack(fill=tk.X, pady=5)
        
        # Resultado - Mostrar imagen/video generado
        result_frame = ttk.LabelFrame(self, text="Resultado")
        result_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Para mostrar la imagen/frame generada
        self.image_canvas = tk.Canvas(result_frame, bg="black", height=400)
        self.image_canvas.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Para mostrar texto descriptivo
        self.result_text = tk.Text(result_frame, height=5, width=70, wrap=tk.WORD, font=("Arial", 10))
        self.result_text.pack(fill=tk.X, expand=False, padx=5, pady=5)
        self.result_text.config(state=tk.DISABLED)
        
        # Inicializar opciones según tipo seleccionado
        self.update_options()
    
    def update_options(self):
        """Actualiza las opciones visibles según el tipo de generación seleccionado"""
        if self.generation_type.get() == "image":
            self.image_options_frame.pack(fill=tk.X, padx=5, pady=5)
            self.video_options_frame.pack_forget()
        else:
            self.image_options_frame.pack_forget()
            self.video_options_frame.pack(fill=tk.X, padx=5, pady=5)
    
    def generate_media(self):
        """Genera una imagen o video según las opciones seleccionadas"""
        prompt = self.prompt_text.get("1.0", tk.END).strip()
        if not prompt:
            messagebox.showerror("Error", "Por favor, describe lo que quieres generar")
            return
        
        provider_type = self.provider_var.get()
        generation_type = self.generation_type.get()
        
        # Verificar que el proveedor tiene una API key configurada
        global current_llm_provider
        if not current_llm_provider or current_llm_provider.__class__.__name__.lower() != f"{provider_type}provider":
            messagebox.showerror("Error", f"El proveedor {provider_type.upper()} no está configurado. "
                               "Por favor, configura el API en la pestaña de Chat primero.")
            return
        
        self.current_provider = provider_type
        
        # Iniciar generación
        self.generating = True
        self.generate_button.config(state=tk.DISABLED)
        self.save_button.config(state=tk.DISABLED)
        self.status_label.config(text=f"Generando {'imagen' if generation_type == 'image' else 'video'}...")
        self.progress_bar.start(10)
        
        # Ejecutar en un hilo para no bloquear la UI
        threading.Thread(target=self._generate_thread, args=(prompt,), daemon=True).start()
    
    def _generate_thread(self, prompt):
        """Hilo para generar contenido sin bloquear la UI"""
        try:
            global current_llm_provider
            result = None
            message = ""
            
            if self.generation_type.get() == "image":
                # Obtener parámetros para generación de imagen
                size = self.size_var.get()
                model = self.model_var.get()
                quality = self.quality_var.get()
                style = self.style_var.get()
                
                if self.current_provider == "openai":
                    # Generar imagen con OpenAI
                    result, message = current_llm_provider.generate_image(
                        prompt=prompt,
                        size=size,
                        model=model,
                        quality=quality,
                        style=style
                    )
                elif self.current_provider in ["gemini", "anthropic"]:
                    # Generar descripción para imagen
                    result, message = current_llm_provider.generate_image(
                        prompt=prompt,
                        size=size
                    )
            else:
                # Parámetros para generación de video
                duration = self.duration_var.get()
                video_model = self.video_model_var.get()
                video_quality = self.video_quality_var.get()
                
                if self.current_provider == "openai":
                    # Generar video con OpenAI (o simulación)
                    result, message = current_llm_provider.generate_video(
                        prompt=prompt,
                        duration=duration,
                        model=video_model,
                        quality=video_quality
                    )
                else:
                    message = f"La generación de videos no está disponible con el proveedor {self.current_provider}"
            
            # Actualizar UI con el resultado
            self.after(0, lambda: self._update_result(result, message))
            
        except Exception as e:
            error_msg = f"Error al generar contenido: {str(e)}"
            logger.error(error_msg)
            self.after(0, lambda: self._update_result(None, error_msg))
    
    def _update_result(self, result, message):
        """Actualiza la UI con el resultado de la generación"""
        self.generating = False
        self.progress_bar.stop()
        self.generate_button.config(state=tk.NORMAL)
        
        if result:
            # Actualizar estado
            self.status_label.config(text="Generación completada")
            self.save_button.config(state=tk.NORMAL)
            
            # Guardar resultado para uso posterior
            if self.generation_type.get() == "image":
                self.current_image = result
                self.current_video = None
                
                # Mostrar imagen en el canvas
                if result.get("data"):  # Datos de imagen en memoria
                    img_data = result["data"]
                    self._display_image(img_data)
                elif result.get("local_path") and os.path.exists(result["local_path"]):
                    # Cargar desde archivo local
                    self._display_image_from_file(result["local_path"])
                
                # Mostrar información adicional
                revised_prompt = result.get("revised_prompt", "")
                if revised_prompt:
                    self._update_result_text(f"Prompt revisado: {revised_prompt}\n\n{message}")
                else:
                    self._update_result_text(message)
                    
            else:  # Video
                self.current_video = result
                self.current_image = None
                
                # Para video, mostramos un frame representativo
                if result.get("type") == "video_simulation" and result.get("frame_image"):
                    frame_image = result["frame_image"]
                    if frame_image.get("data"):
                        self._display_image(frame_image["data"])
                    elif frame_image.get("local_path") and os.path.exists(frame_image["local_path"]):
                        self._display_image_from_file(frame_image["local_path"])
                
                # Mostrar descripción del video
                description = result.get("description", "")
                self._update_result_text(f"{message}\n\n{description}")
        else:
            # Mostrar mensaje de error o descripción
            self.status_label.config(text="No se pudo generar contenido")
            self._update_result_text(message)
            self.current_image = None
            self.current_video = None
    
    def _display_image(self, img_data):
        """Muestra una imagen desde datos en memoria"""
        try:
            if isinstance(img_data, BytesIO):
                pil_img = Image.open(img_data)
            else:
                # Asumimos que es un objeto de respuesta o bytes
                img_bytes = img_data.content if hasattr(img_data, 'content') else img_data
                pil_img = Image.open(BytesIO(img_bytes))
            
            # Redimensionar para ajustar al canvas, manteniendo aspecto
            canvas_width = self.image_canvas.winfo_width()
            canvas_height = self.image_canvas.winfo_height()
            
            img_width, img_height = pil_img.size
            ratio = min(canvas_width/img_width, canvas_height/img_height)
            new_width = int(img_width * ratio)
            new_height = int(img_height * ratio)
            
            pil_img = pil_img.resize((new_width, new_height), Image.LANCZOS)
            
            # Convertir a PhotoImage para mostrar en el canvas
            self.photo_image = ImageTk.PhotoImage(pil_img)
            
            # Limpiar canvas y mostrar imagen
            self.image_canvas.delete("all")
            x = (canvas_width - new_width) // 2
            y = (canvas_height - new_height) // 2
            self.image_canvas.create_image(x, y, anchor=tk.NW, image=self.photo_image)
        except Exception as e:
            logger.error(f"Error al mostrar imagen: {str(e)}")
            self.image_canvas.delete("all")
            self.image_canvas.create_text(
                self.image_canvas.winfo_width() // 2,
                self.image_canvas.winfo_height() // 2,
                text="Error al mostrar imagen",
                fill="white",
                font=("Arial", 14)
            )
    
    def _display_image_from_file(self, file_path):
        """Muestra una imagen desde un archivo"""
        try:
            with open(file_path, "rb") as f:
                img_data = BytesIO(f.read())
            self._display_image(img_data)
        except Exception as e:
            logger.error(f"Error al cargar imagen desde archivo: {str(e)}")
    
    def _update_result_text(self, text):
        """Actualiza el área de texto con información sobre el resultado"""
        self.result_text.config(state=tk.NORMAL)
        self.result_text.delete("1.0", tk.END)
        self.result_text.insert(tk.END, text)
        self.result_text.config(state=tk.DISABLED)
    
    def save_media(self):
        """Guarda la imagen o video generado"""
        if not self.current_image and not self.current_video:
            messagebox.showinfo("Información", "No hay contenido para guardar")
            return
        
        if self.generation_type.get() == "image" and self.current_image:
            # Guardar imagen
            file_path = filedialog.asksaveasfilename(
                title="Guardar imagen",
                defaultextension=".png",
                filetypes=[("PNG", "*.png"), ("JPEG", "*.jpg"), ("Todos los archivos", "*.*")]
            )
            
            if file_path:
                try:
                    # Si ya tenemos un archivo local, copiarlo
                    if self.current_image.get("local_path") and os.path.exists(self.current_image["local_path"]):
                        shutil.copy2(self.current_image["local_path"], file_path)
                    # Si tenemos la URL, descargar y guardar
                    elif self.current_image.get("url"):
                        response = requests.get(self.current_image["url"])
                        with open(file_path, "wb") as f:
                            f.write(response.content)
                    # Si tenemos datos en memoria
                    elif self.current_image.get("data"):
                        with open(file_path, "wb") as f:
                            f.write(self.current_image["data"].getvalue())
                            
                    messagebox.showinfo("Éxito", f"Imagen guardada como {file_path}")
                except Exception as e:
                    messagebox.showerror("Error", f"No se pudo guardar la imagen: {str(e)}")
        
        elif self.generation_type.get() == "video" and self.current_video:
            # Para videos (o simulaciones)
            if self.current_video.get("type") == "video_simulation":
                # Guardar el frame representativo
                file_path = filedialog.asksaveasfilename(
                    title="Guardar frame representativo",
                    defaultextension=".png",
                    filetypes=[("PNG", "*.png"), ("JPEG", "*.jpg"), ("Todos los archivos", "*.*")]
                )
                
                if file_path:
                    try:
                        # Guardar frame de la simulación
                        frame_image = self.current_video.get("frame_image", {})
                        if frame_image.get("local_path") and os.path.exists(frame_image["local_path"]):
                            shutil.copy2(frame_image["local_path"], file_path)
                        elif frame_image.get("url"):
                            response = requests.get(frame_image["url"])
                            with open(file_path, "wb") as f:
                                f.write(response.content)
                                
                        # También guardar la descripción como txt
                        text_path = os.path.splitext(file_path)[0] + ".txt"
                        with open(text_path, "w", encoding="utf-8") as f:
                            f.write(f"PROMPT: {self.prompt_text.get('1.0', tk.END).strip()}\n\n")
                            f.write(f"DESCRIPCIÓN DEL VIDEO: \n{self.current_video.get('description', '')}")
                            
                        messagebox.showinfo("Éxito", 
                                          f"Frame guardado como {file_path}\n"
                                          f"Descripción guardada como {text_path}")
                    except Exception as e:
                        messagebox.showerror("Error", f"No se pudo guardar el contenido: {str(e)}")
    
    def clear_result(self):
        """Limpia el resultado mostrado"""
        self.image_canvas.delete("all")
        self._update_result_text("")
        self.status_label.config(text="")
        self.save_button.config(state=tk.DISABLED)
        self.current_image = None
        self.current_video = None
        self.prompt_text.delete("1.0", tk.END)
        
    def generate_programmatically(self, prompt, generation_type="image", **kwargs):
        """Método para generar contenido programáticamente desde el chatbot"""
        try:
            global current_llm_provider
            if not current_llm_provider:
                return False, "No hay proveedor de IA configurado"
                
            # Cambiar a la pestaña de generación de contenido
            self.generation_type.set(generation_type)
            self.update_options()
            self.prompt_text.delete("1.0", tk.END)
            self.prompt_text.insert("1.0", prompt)
            
            # Actualizar opciones según los parámetros
            if generation_type == "image":
                if "size" in kwargs:
                    self.size_var.set(kwargs["size"])
                if "model" in kwargs:
                    self.model_var.set(kwargs["model"])
                if "quality" in kwargs:
                    self.quality_var.set(kwargs["quality"])
                if "style" in kwargs:
                    self.style_var.set(kwargs["style"])
            else:  # video
                if "duration" in kwargs:
                    self.duration_var.set(kwargs["duration"])
                if "model" in kwargs:
                    self.video_model_var.set(kwargs["model"])
                if "quality" in kwargs:
                    self.video_quality_var.set(kwargs["quality"])
            
            # Iniciar generación
            self.generate_media()
            return True, f"Generando {generation_type} con el prompt: {prompt[:50]}..."
        except Exception as e:
            logger.error(f"Error al generar programáticamente: {str(e)}")
            return False, f"Error: {str(e)}"

###############################################################################
#                      TKINTER SUPER AGENTE (MODIFICADO)
###############################################################################
class MultiAppLauncher:
    def __init__(self, root):
        self.root = root
        self.root.title("TRON ARES by Viaja Tech")
        self.root.geometry("1200x800")
        self.root.resizable(True, True)

        # Word
        self.word_doc = None

        # Excel
        self.excel_app = None
        self.excel_sheet = None

        # Notepad
        self.notepad_temp_file = None
        self.notepad_live_sync = False

        # Browsers
        self.chrome_driver = None
        self.firefox_driver = None

        # Downloader y Player
        self.downloader = None
        self.media_player = None
        
        # Generador de contenido
        self.media_generator = None

        # Social placeholders
        self.social_drivers = {
            'x': None,
            'facebook': None,
            'instagram': None,
            'threads': None,
            'tiktok': None,
            'youtube': None,
            'github': None,
            'vimeo': None
        }

        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(pady=10, expand=True, fill=tk.BOTH)

        self.text_areas = {}
        self.last_update = 0
        self.update_delay = 500

        if os.name != 'nt':
            messagebox.showerror("SO no compatible", "Este script sólo funciona en Windows.")
            self.root.destroy()
            sys.exit()

        self.create_all_tabs()

        close_btn = tk.Button(
            self.root,
            text="Cerrar Aplicación",
            command=self.cerrar_aplicacion,
            bg="#FF0000",
            fg="white",
            font=("Arial", 12),
            padx=20,
            pady=10
        )
        close_btn.pack(pady=5)

    def create_all_tabs(self):
        self.create_notepad_tab()
        self.create_word_tab()
        self.create_excel_tab()
        self.create_firefox_tab()
        self.create_chrome_tab()
        
        # Pestañas para multimedia
        self.create_downloader_tab()
        self.create_media_player_tab()
        
        # Nueva pestaña para generación de contenido IA
        self.create_media_generation_tab()

    # ------------------ NOTEPAD ------------------
    def create_notepad_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Bloc de Notas / Notepad")

        lbl = tk.Label(tab, text="Texto para Notepad:", font=("Arial", 12))
        lbl.pack(pady=5)

        frame_txt = tk.Frame(tab)
        frame_txt.pack(pady=5, padx=10, fill=tk.BOTH, expand=True)

        scrollbar = tk.Scrollbar(frame_txt)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        text_area = tk.Text(
            frame_txt,
            wrap=tk.WORD,
            width=80,
            height=20,
            font=("Arial", 12),
            yscrollcommand=scrollbar.set
        )
        text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=text_area.yview)

        self.text_areas['notepad'] = text_area
        text_area.bind('<KeyRelease>', lambda e: self.on_text_change(text_area))

        btn_notepad_once = tk.Button(
            tab,
            text="Abrir Notepad (una vez)",
            command=lambda: self.enviar_a_notepad_una_vez(text_area),
            bg="#555555",
            fg="white",
            font=("Arial", 12),
            padx=20,
            pady=10
        )
        btn_notepad_once.pack(pady=5)

    def enviar_a_notepad_una_vez(self, text_widget):
        texto = text_widget.get("1.0", tk.END).strip()
        if not texto:
            messagebox.showwarning("Aviso", "Ingresa texto antes de abrir Notepad.")
            return
        try:
            with tempfile.NamedTemporaryFile(delete=False, suffix=".txt", mode='w', encoding='utf-8') as tmp:
                tmp.write(texto)
                self.notepad_temp_file = tmp.name

            subprocess.Popen(['notepad.exe', self.notepad_temp_file])
            self.notepad_live_sync = False
            self._auto_save_notepad_immediate()

        except Exception as e:
            logger.warning(f"Error Notepad: {e}")

    def _auto_save_notepad_immediate(self):
        if not self.notepad_temp_file:
            return
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        default_path = os.path.join(os.getcwd(), f"auto_saved_notepad_{ts}.txt")
        try:
            with open(self.notepad_temp_file, 'r', encoding='utf-8') as src:
                content = src.read()
            with open(default_path, 'w', encoding='utf-8') as dst:
                dst.write(content)
            logger.warning(f"[Auto-Saved Notepad] => {default_path}")
        except Exception as e:
            logger.warning(f"Error auto-saving Notepad: {e}")

    def cerrar_notepad_process(self):
        try:
            for proc in psutil.process_iter(['pid', 'name']):
                if proc.info['name'] and proc.info['name'].lower() == "notepad.exe":
                    proc.kill()
        except Exception as e:
            logger.warning(f"Error cerrando Notepad: {e}")

    def update_notepad_live(self, new_text):
        if not self.notepad_temp_file:
            return
        self.cerrar_notepad_process()
        time.sleep(0.5)
        try:
            with open(self.notepad_temp_file, 'w', encoding='utf-8') as f:
                f.write(new_text)
            subprocess.Popen(['notepad.exe', self.notepad_temp_file])
        except Exception as e:
            logger.warning(f"Error update_notepad_live: {e}")

    def auto_save_notepad(self):
        if not self.notepad_temp_file:
            messagebox.showwarning("No se puede guardar", "No hay Notepad abierto.")
            return
        path = filedialog.asksaveasfilename(
            title="Guardar Notepad",
            defaultextension=".txt",
            filetypes=[("Archivo de texto", "*.txt"), ("Todos los archivos", "*.*")]
        )
        if path:
            try:
                with open(self.notepad_temp_file, 'r', encoding='utf-8') as src:
                    content = src.read()
                with open(path, 'w', encoding='utf-8') as dst:
                    dst.write(content)
                messagebox.showinfo("Guardado", f"Notepad guardado en:\n{path}")
            except Exception as e:
                messagebox.showerror("Error", f"No se pudo guardar Notepad:\n{e}")

    # ------------------ WORD ------------------
    def create_word_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Microsoft Word")

        lbl = tk.Label(tab, text="Texto para Word:", font=("Arial", 12))
        lbl.pack(pady=5)

        frame_txt = tk.Frame(tab)
        frame_txt.pack(pady=5, padx=10, fill=tk.BOTH, expand=True)

        scrollbar = tk.Scrollbar(frame_txt)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        text_area = tk.Text(
            frame_txt,
            wrap=tk.WORD,
            width=80,
            height=20,
            font=("Arial", 12),
            yscrollcommand=scrollbar.set
        )
        text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=text_area.yview)

        self.text_areas['word'] = text_area
        text_area.bind('<KeyRelease>', lambda e: self.on_text_change(text_area))

        btn_word = tk.Button(
            tab,
            text="Abrir Word",
            command=lambda: self.abrir_word(text_area),
            bg="#4CAF50",
            fg="white",
            font=("Arial", 12),
            padx=20,
            pady=10
        )
        btn_word.pack(pady=5)

    def abrir_word(self, text_widget):
        texto = text_widget.get("1.0", tk.END).strip()
        try:
            # Limpia la caché para evitar problemas
            clear_win32com_cache()
            
            pythoncom.CoInitialize()
            if not self.word_doc:
                word = win32.Dispatch('Word.Application')
                word.Visible = True
                self.word_doc = word.Documents.Add()
            self.word_doc.Content.Text = texto
            self._auto_save_word_immediate()
        except Exception as e:
            logger.warning(f"Error abrir_word: {e}")
            messagebox.showerror("Error al abrir Word", f"Hubo un problema: {str(e)}\nIntentando recuperar...")
            try:
                # Segundo intento después de limpiar caché
                clear_win32com_cache()
                pythoncom.CoInitialize()
                word = win32.Dispatch('Word.Application')
                word.Visible = True
                self.word_doc = word.Documents.Add()
                self.word_doc.Content.Text = texto
                self._auto_save_word_immediate()
            except Exception as e2:
                logger.error(f"Error crítico en Word: {e2}")
                messagebox.showerror("Error crítico", f"No se pudo iniciar Word: {str(e2)}")
        finally:
            pythoncom.CoUninitialize()

    def _auto_save_word_immediate(self):
        try:
            if self.word_doc:
                ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                default_path = os.path.join(os.getcwd(), f"auto_saved_word_{ts}.docx")
                self.word_doc.SaveAs2(default_path)
                logger.warning(f"[Auto-Saved Word] => {default_path}")
        except Exception as e:
            logger.warning(f"Error auto_save_word_immediate: {e}")

    def update_word(self, texto):
        try:
            pythoncom.CoInitialize()
            if self.word_doc:
                self.word_doc.Content.Text = texto
        except Exception as e:
            logger.warning(f"Error update_word: {e}")
        finally:
            pythoncom.CoUninitialize()

    def abrir_word_con_historia(self, texto):
        try:
            # Limpia la caché para evitar problemas
            clear_win32com_cache()
            
            pythoncom.CoInitialize()
            word = win32.Dispatch('Word.Application')
            word.Visible = True
            self.word_doc = word.Documents.Add()
            self.word_doc.Content.Text = texto
            self._auto_save_word_immediate()
        except Exception as e:
            logger.warning(f"Error abrir_word_con_historia: {e}")
            messagebox.showerror("Error al abrir Word", f"Hubo un problema: {str(e)}\nIntentando recuperar...")
            try:
                # Segundo intento después de limpiar caché
                clear_win32com_cache()
                pythoncom.CoInitialize()
                word = win32.Dispatch('Word.Application')
                word.Visible = True
                self.word_doc = word.Documents.Add()
                self.word_doc.Content.Text = texto
                self._auto_save_word_immediate()
            except Exception as e2:
                logger.error(f"Error crítico en Word: {e2}")
                messagebox.showerror("Error crítico", f"No se pudo iniciar Word: {str(e2)}")
        finally:
            pythoncom.CoUninitialize()

    def auto_save_word(self):
        try:
            pythoncom.CoInitialize()
            if not self.word_doc:
                messagebox.showwarning("Word no abierto", "No hay documento Word para guardar.")
                return
            path = filedialog.asksaveasfilename(
                title="Guardar Word",
                defaultextension=".docx",
                filetypes=[("Documento Word", "*.docx"), ("Todos los archivos", "*.*")]
            )
            if path:
                self.word_doc.SaveAs2(path)
                messagebox.showinfo("Guardado", f"Documento Word guardado:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo guardar Word:\n{e}")
        finally:
            pythoncom.CoUninitialize()

    # ------------------ EXCEL ------------------
    def create_excel_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Microsoft Excel")

        lbl = tk.Label(tab, text="Texto para Excel (una línea por celda en Columna A):", font=("Arial", 12))
        lbl.pack(pady=5)

        frame_txt = tk.Frame(tab)
        frame_txt.pack(pady=5, padx=10, fill=tk.BOTH, expand=True)

        scrollbar = tk.Scrollbar(frame_txt)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        text_area = tk.Text(
            frame_txt,
            wrap=tk.WORD,
            width=70,
            height=12,
            font=("Arial", 12),
            yscrollcommand=scrollbar.set
        )
        text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=text_area.yview)

        self.text_areas['excel'] = text_area
        text_area.bind('<KeyRelease>', lambda e: self.on_text_change(text_area))

        btn_excel = tk.Button(
            tab,
            text="Abrir Excel",
            command=lambda: self.abrir_excel(text_area),
            bg="#FF9800",
            fg="white",
            font=("Arial", 12),
            padx=20,
            pady=10
        )
        btn_excel.pack(pady=5)

        # Frame para fórmula
        formula_frame = tk.LabelFrame(tab, text="Aplicar Fórmula en Excel")
        formula_frame.pack(pady=5, padx=10, fill=tk.X)

        lbl_cell = tk.Label(formula_frame, text="Celda (Ej: A1):", font=("Arial", 10))
        lbl_cell.grid(row=0, column=0, padx=5, pady=5, sticky="e")
        self.excel_cell_entry = tk.Entry(formula_frame, width=10)
        self.excel_cell_entry.grid(row=0, column=1, padx=5, pady=5)

        lbl_formula = tk.Label(formula_frame, text="Fórmula (Ej: =1+1):", font=("Arial", 10))
        lbl_formula.grid(row=0, column=2, padx=5, pady=5, sticky="e")
        self.excel_formula_entry = tk.Entry(formula_frame, width=20)
        self.excel_formula_entry.grid(row=0, column=3, padx=5, pady=5)

        btn_set_formula = tk.Button(
            formula_frame,
            text="Aplicar Fórmula",
            command=self.aplicar_formula_excel,
            bg="#3F51B5",
            fg="white",
            font=("Arial", 10),
            padx=10,
            pady=5
        )
        btn_set_formula.grid(row=0, column=4, padx=5, pady=5)

    def abrir_excel(self, text_widget):
        texto = text_widget.get("1.0", tk.END)
        self.write_in_excel(texto)

    def write_in_excel(self, texto):
        lines = texto.split('\n')
        for intento in range(3):  # Aumentamos el número de intentos
            try:
                # Limpia la caché en cada intento
                if intento > 0:
                    clear_win32com_cache()
                
                pythoncom.CoInitialize()
                if not self.excel_app or not self.excel_sheet:
                    # Usar Dispatch en lugar de gencache.EnsureDispatch para evitar problemas de caché
                    self.excel_app = win32.Dispatch('Excel.Application')
                    self.excel_app.Visible = True
                    wb = self.excel_app.Workbooks.Add()
                    self.excel_sheet = wb.Worksheets(1)

                row = 1
                for line in lines:
                    if line.strip():  # Solo procesar líneas no vacías
                        self.excel_sheet.Cells(row, 1).Value = line
                        row += 1

                self._auto_save_excel_immediate()
                logger.info("Excel abierto y contenido escrito correctamente")
                return
            except pywintypes.com_error as e:
                logger.warning(f"Error COM Excel (intento {intento+1}): {e}")
                if self.excel_app:
                    try:
                        self.excel_app.Quit()
                    except:
                        pass
                self.excel_app = None
                self.excel_sheet = None
                
                # En el último intento, mostrar un mensaje de error
                if intento == 2:
                    logger.error(f"Error crítico en Excel después de 3 intentos: {e}")
                    messagebox.showerror("Error con Excel", 
                                        "No se pudo abrir Excel después de varios intentos.\n"
                                        "Intente reiniciar la aplicación.")
            except Exception as e:
                logger.warning(f"Error general Excel (intento {intento+1}): {e}")
                if intento == 2:
                    logger.error(f"Error crítico general en Excel: {e}")
                    messagebox.showerror("Error con Excel", f"Error general: {str(e)}")
            finally:
                pythoncom.CoUninitialize()

    def _auto_save_excel_immediate(self):
        try:
            pythoncom.CoInitialize()
            if self.excel_app and self.excel_sheet:
                ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
                default_path = os.path.join(os.getcwd(), f"auto_saved_excel_{ts}.xlsx")
                wb = self.excel_app.ActiveWorkbook
                wb.SaveAs(default_path)
                logger.warning(f"[Auto-Saved Excel] => {default_path}")
        except Exception as e:
            logger.warning(f"Error auto_save_excel_immediate: {e}")
        finally:
            pythoncom.CoUninitialize()

    def auto_save_excel(self):
        try:
            pythoncom.CoInitialize()
            if not self.excel_app or not self.excel_sheet:
                messagebox.showwarning("Excel no abierto", "No hay libro Excel para guardar.")
                return
            path = filedialog.asksaveasfilename(
                title="Guardar Excel",
                defaultextension=".xlsx",
                filetypes=[("Libro Excel", "*.xlsx"), ("Todos los archivos", "*.*")]
            )
            if path:
                wb = self.excel_app.ActiveWorkbook
                wb.SaveAs(path)
                messagebox.showinfo("Guardado", f"Libro Excel guardado:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo guardar Excel:\n{e}")
        finally:
            pythoncom.CoUninitialize()

    def aplicar_formula_excel(self):
        if not self.excel_app or not self.excel_sheet:
            messagebox.showwarning("Excel no abierto", "Primero abre Excel antes de aplicar fórmula.")
            return
        cell_str = self.excel_cell_entry.get().strip()
        formula_str = self.excel_formula_entry.get().strip()
        if not cell_str or not formula_str:
            messagebox.showwarning("Campos vacíos", "Indica celda y fórmula.")
            return
        try:
            pythoncom.CoInitialize()
            wb = self.excel_app.ActiveWorkbook
            sht = wb.ActiveSheet
            sht.Range(cell_str).Formula = formula_str
            messagebox.showinfo("Fórmula aplicada", f"Celda {cell_str} = {formula_str}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo aplicar la fórmula:\n{e}")
        finally:
            pythoncom.CoUninitialize()

    # ------------------- BROWSERS (CHROME / FIREFOX) -------------------
    def create_firefox_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Buscar en Firefox")

        lbl = tk.Label(tab, text="Texto para Firefox (búsqueda):", font=("Arial", 12))
        lbl.pack(pady=5)

        frame_txt = tk.Frame(tab)
        frame_txt.pack(pady=5, padx=10, fill=tk.BOTH, expand=True)

        scrollbar = tk.Scrollbar(frame_txt)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        text_area = tk.Text(
            frame_txt, wrap=tk.WORD, width=80, height=10,
            font=("Arial", 12),
            yscrollcommand=scrollbar.set
        )
        text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=text_area.yview)

        self.text_areas['firefox'] = text_area
        text_area.bind('<KeyRelease>', lambda e: self.on_text_change(text_area))

        btn_ff = tk.Button(
            tab,
            text="Abrir/Búsqueda en Firefox",
            command=lambda: self.abrir_firefox(text_area),
            bg="#FF7139",
            fg="white",
            font=("Arial", 12),
            padx=20,
            pady=10
        )
        btn_ff.pack(pady=5)

    def create_chrome_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Buscar en Chrome")

        lbl = tk.Label(tab, text="Texto para Chrome (búsqueda):", font=("Arial", 12))
        lbl.pack(pady=5)

        frame_txt = tk.Frame(tab)
        frame_txt.pack(pady=5, padx=10, fill=tk.BOTH, expand=True)

        scrollbar = tk.Scrollbar(frame_txt)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        text_area = tk.Text(
            frame_txt, wrap=tk.WORD, width=80, height=10,
            font=("Arial", 12),
            yscrollcommand=scrollbar.set
        )
        text_area.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.config(command=text_area.yview)

        self.text_areas['chrome'] = text_area
        text_area.bind('<KeyRelease>', lambda e: self.on_text_change(text_area))

        btn_chrome = tk.Button(
            tab,
            text="Abrir/Búsqueda en Chrome",
            command=lambda: self.abrir_chrome(text_area),
            bg="#4285F4",
            fg="white",
            font=("Arial", 12),
            padx=20,
            pady=10
        )
        btn_chrome.pack(pady=5)

    def abrir_firefox(self, text_widget):
        texto = text_widget.get("1.0", tk.END).strip()
        try:
            if not self.firefox_driver:
                service = FirefoxService(executable_path=GeckoDriverManager().install())
                options = webdriver.FirefoxOptions()
                options.add_argument("--start-maximized")
                self.firefox_driver = webdriver.Firefox(service=service, options=options)
            self.update_browsers('firefox', texto, "Todo")
        except Exception as e:
            logger.warning(f"Error abrir_firefox: {e}")

    def abrir_chrome(self, text_widget):
        texto = text_widget.get("1.0", tk.END).strip()
        try:
            if not self.chrome_driver:
                service = ChromeService(executable_path=ChromeDriverManager().install())
                options = webdriver.ChromeOptions()
                options.add_argument("--start-maximized")
                options.add_experimental_option('excludeSwitches', ['enable-logging'])
                self.chrome_driver = webdriver.Chrome(service=service, options=options)
            threading.Thread(
                target=self.update_browsers,
                args=('chrome', texto, "Todo"),
                daemon=True
            ).start()
        except Exception as e:
            logger.warning(f"Error abrir_chrome: {e}")

    def abrir_chrome_fake(self, raw_search):
        try:
            if not self.chrome_driver:
                service = ChromeService(executable_path=ChromeDriverManager().install())
                options = webdriver.ChromeOptions()
                options.add_argument("--start-maximized")
                options.add_experimental_option('excludeSwitches', ['enable-logging'])
                self.chrome_driver = webdriver.Chrome(service=service, options=options)
            self.update_browsers('chrome', raw_search, "Todo")
        except Exception as e:
            logger.warning(f"Error abrir_chrome_fake: {e}")

    def abrir_firefox_fake(self, raw_search):
        try:
            if not self.firefox_driver:
                service = FirefoxService(executable_path=GeckoDriverManager().install())
                options = webdriver.FirefoxOptions()
                options.add_argument("--start-maximized")
                self.firefox_driver = webdriver.Firefox(service=service, options=options)
            self.update_browsers('firefox', raw_search, "Todo")
        except Exception as e:
            logger.warning(f"Error abrir_firefox_fake: {e}")

    def update_browsers(self, browser_key, texto, default_section):
        """
        Corrige "en hoteles para perritos" => "hoteles para perritos"
        Mismo con "en maps", etc.
        """
        ltxt = texto.lower()

        # 1) Revisar si "maps"
        # Si el usuario dice "en maps", lo removemos
        # por ejemplo: "busca en maps hoteles para perritos" => subject = "hoteles para perritos"
        if "map" in ltxt:
            # remover "en maps" o "maps" en la parte sobrante
            # para no generarle "en++"
            parted = ltxt.split("maps", maxsplit=1)
            # parted[-1], remove leading "en "
            subject = parted[-1].strip()
            if subject.startswith("en "):
                subject = subject[3:].strip()
            # apply normal removal logic
            #  (handled below with remove_phrases if needed)
            # then do google maps search
            # we return after building the url
            # but let's keep the standard logic for partial synergy
            # so we reassign ltxt to some placeholder
            ltxt = "maps " + subject

        # 2) Revisar "spotify"
        if "spotify" in ltxt:
            # placeholder => open "https://open.spotify.com/"
            try:
                url = "https://open.spotify.com/"
                if browser_key == 'firefox' and self.firefox_driver:
                    self.firefox_driver.get(url)
                elif browser_key == 'chrome' and self.chrome_driver:
                    self.chrome_driver.get(url)
                return
            except Exception as e:
                logger.warning(f"Error abrir Spotify: {e}")
                return

        # 3) videos en youtube
        if "video" in ltxt and "youtube" in ltxt:
            parted = ltxt.split("youtube", maxsplit=1)
            subject = parted[-1].strip()
            if subject.startswith("de "):
                subject = subject[3:].strip()
            for rp in ["videos en", "videos", "video en", "video", "de"]:
                idx = subject.find(rp)
                if idx != -1:
                    subject = subject[:idx] + subject[idx+len(rp):]
            subject = subject.strip()
            if not subject:
                subject = "videos"

            q = urllib.parse.quote_plus(subject)
            url = f"https://www.youtube.com/results?search_query={q}"
            try:
                if browser_key == 'firefox' and self.firefox_driver:
                    self.firefox_driver.get(url)
                elif browser_key == 'chrome' and self.chrome_driver:
                    self.chrome_driver.get(url)
            except Exception as e:
                logger.warning(f"Error youtube: {e}")
            return

        # 4) videos en vimeo
        if "video" in ltxt and "vimeo" in ltxt:
            parted = ltxt.split("vimeo", maxsplit=1)
            subject = parted[-1].strip()
            if subject.startswith("de "):
                subject = subject[3:].strip()
            for rp in ["videos en", "videos", "video en", "video", "de"]:
                idx = subject.find(rp)
                if idx != -1:
                    subject = subject[:idx] + subject[idx+len(rp):]
            subject = subject.strip()
            if not subject:
                subject = "videos"
            q = urllib.parse.quote_plus(subject)
            url = f"https://vimeo.com/search?q={q}"
            try:
                if browser_key == 'firefox' and self.firefox_driver:
                    self.firefox_driver.get(url)
                elif browser_key == 'chrome' and self.chrome_driver:
                    self.chrome_driver.get(url)
            except Exception as e:
                logger.warning(f"Error vimeo: {e}")
            return

        # 5) Secciones normales
        sec = default_section
        if "imagen" in ltxt or "foto" in ltxt:
            sec = "Imágenes"
        elif "video" in ltxt:
            sec = "Videos"
        elif "map" in ltxt:
            sec = "Maps"
        elif "noticia" in ltxt:
            sec = "Noticias"
        elif "shopping" in ltxt or "comprar" in ltxt:
            sec = "Shopping"
        elif "libro" in ltxt:
            sec = "Libros"

        remove_phrases = [
            "fotos de", "fotos", "imagenes de", "imágenes de", "imágenes",
            "videos de", "videos", "video de", "video", "videos en", "video en",
            "noticias de", "noticia de", "noticias", "noticia",
            "maps de", "map de", "maps", "map",
            "shopping de", "shopping", "comprar",
            "libros de", "libro de", "libros", "libro"
        ]
        subject = texto
        for rp in remove_phrases:
            idx = subject.lower().find(rp)
            if idx != -1:
                subject = subject[:idx] + subject[idx+len(rp):]
        subject = subject.strip()
        if subject.startswith("en "):
            subject = subject[3:].strip()
        if not subject:
            subject = texto

        section_map = {
            "Todo":     "",
            "Imágenes": "isch",
            "Videos":   "vid",
            "Maps":     "maps",
            "Noticias": "nws",
            "Shopping": "shop",
            "Libros":   "bks"
        }

        query = urllib.parse.quote_plus(subject)
        if sec == "Maps":
            url = f"https://www.google.com/maps/search/?api=1&query={query}"
        else:
            tbm = section_map.get(sec, "")
            if tbm:
                url = f"https://www.google.com/search?q={query}&tbm={tbm}"
            else:
                url = f"https://www.google.com/search?q={query}"

        try:
            if browser_key == 'firefox' and self.firefox_driver:
                self.firefox_driver.get(url)
            elif browser_key == 'chrome' and self.chrome_driver:
                self.chrome_driver.get(url)
        except Exception as e:
            logger.warning(f"Error update_browsers: {e}")

    # -------------- Placeholders Redes Sociales --------------
    def login_social_media(self, platform, user, password):
        pass

    def post_social_media(self, platform, text, media_path=None):
        pass
    
    # ----------------- NUEVAS PESTAÑAS (MULTIMEDIA) -----------------
    def create_downloader_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Descargar Música/Videos")
        
        # Crear instancia del descargador dentro de esta pestaña
        self.downloader = VideoDownloaderFrame(tab)
        self.downloader.pack(fill=tk.BOTH, expand=True)
    
    def create_media_player_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Reproductor Multimedia")
        
        # Crear instancia del reproductor multimedia dentro de esta pestaña
        self.media_player = MediaPlayerFrame(tab)
        self.media_player.pack(fill=tk.BOTH, expand=True)
    
    def create_media_generation_tab(self):
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Generador IA")
        
        # Crear instancia del generador de imágenes/videos
        self.media_generator = MediaGenerationFrame(tab)
        self.media_generator.pack(fill=tk.BOTH, expand=True)

    # -------------- TEXT CHANGE / CERRAR ---------------------
    def on_text_change(self, text_widget):
        cur_time = time.time() * 1000
        if cur_time - self.last_update >= self.update_delay:
            self.last_update = cur_time
            texto = text_widget.get("1.0", tk.END)
            for k, area in self.text_areas.items():
                if text_widget == area:
                    if k == 'word' and self.word_doc:
                        self.update_word(texto)
                    elif k == 'excel' and self.excel_sheet:
                        self.write_in_excel(texto)
                    elif k == 'notepad' and self.notepad_live_sync:
                        threading.Thread(
                            target=self.update_notepad_live,
                            args=(texto,),
                            daemon=True
                        ).start()
                    elif k == 'firefox' and self.firefox_driver:
                        threading.Thread(
                            target=self.update_browsers,
                            args=('firefox', texto, "Todo"),
                            daemon=True
                        ).start()
                    elif k == 'chrome' and self.chrome_driver:
                        threading.Thread(
                            target=self.update_browsers,
                            args=('chrome', texto, "Todo"),
                            daemon=True
                        ).start()

    def cerrar_aplicacion(self):
        try:
            pythoncom.CoInitialize()
            if self.word_doc:
                self.word_doc.Application.Quit()
                self.word_doc = None
            if self.excel_app:
                self.excel_app.Quit()
                self.excel_app = None
                self.excel_sheet = None
        except:
            pass
        finally:
            pythoncom.CoUninitialize()

        if self.chrome_driver:
            self.chrome_driver.quit()
            self.chrome_driver = None
        if self.firefox_driver:
            self.firefox_driver.quit()
            self.firefox_driver = None

        # Detener reproducción de media si está activa
        if pygame_available:
            try:
                pygame.mixer.quit()
                pygame.quit()
            except:
                pass
        
        self.cerrar_notepad_process()
        self.root.destroy()
        sys.exit()

    def main(self):
        self.root.mainloop()
    
    # ------------------- FUNCIONES MULTIMEDIA -------------------
    def download_media(self, url, is_audio=False, format_type="mp4"):
        """Método para iniciar descargas desde el chatbot"""
        # Usamos la función directa en lugar de la interfaz gráfica
        if self.downloader:
            self.notebook.select(self.notebook.index("Descargar Música/Videos"))
        
        logger.info(f"Solicitud de descarga desde chatbot: {url}, audio={is_audio}, formato={format_type}")
        return direct_download_media(url, is_audio, format_type)
    
    def play_media(self, filename):
        """Método para reproducir archivos multimedia desde el chatbot"""
        if self.media_player:
            success = self.media_player.play_file_by_name(filename)
            if success:
                self.notebook.select(self.notebook.index("Reproductor Multimedia"))
                return True, f"Reproduciendo {filename}"
            else:
                self.media_player.refresh_from_downloads()
                # Intentar de nuevo después de actualizar
                success = self.media_player.play_file_by_name(filename)
                if success:
                    self.notebook.select(self.notebook.index("Reproductor Multimedia"))
                    return True, f"Reproduciendo {filename}"
            return False, f"No se encontró {filename} en la lista de reproducción"
        return False, "Reproductor multimedia no inicializado"
    
    def stop_media(self):
        """Detiene la reproducción actual"""
        if self.media_player:
            self.media_player.stop()
            return True, "Reproducción detenida"
        return False, "Reproductor multimedia no inicializado"
    
    def generate_image(self, prompt, **kwargs):
        """Método para generar imágenes desde el chatbot"""
        if self.media_generator:
            success, message = self.media_generator.generate_programmatically(prompt, "image", **kwargs)
            if success:
                self.notebook.select(self.notebook.index("Generador IA"))
            return success, message
        return False, "Generador de contenido no inicializado"
    
    def generate_video(self, prompt, **kwargs):
        """Método para generar videos desde el chatbot"""
        if self.media_generator:
            success, message = self.media_generator.generate_programmatically(prompt, "video", **kwargs)
            if success:
                self.notebook.select(self.notebook.index("Generador IA"))
            return success, message
        return False, "Generador de contenido no inicializado"

###############################################################################
#                           LM STUDIO + TEST TIME
###############################################################################
client = OpenAI(base_url="http://localhost:1234/v1", api_key="lm-studio")

def speak_text_azure(text, voice_gender):
    pass

def transcribe_audio():
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("Escuchando... Habla ahora")
        audio = r.listen(source)
    try:
        texto = r.recognize_google(audio, language='es-ES')
        print(f"Has dicho: {texto}")
        return texto
    except:
        print("No pude entender lo que dijiste")
        return "No pude entender el audio."

def build_conversation_history(messages):
    hist = []
    for m in messages:
        if m["role"] == "user":
            hist.append(f"Usuario: {m['content']}")
        elif m["role"] == "assistant":
            hist.append(f"Asistente: {m['content']}")
    return "\n".join(hist)

def dummy_reward_function(text):
    return len(text)

def strategy_simple(context, user_message, depth, model, temperature, full_messages=None):
    global current_llm_provider
    
    if full_messages is not None:
        c_hist = build_conversation_history(full_messages)
        context = f"{context}\n\nHistorial:\n{c_hist}"

    prompt = f"""
Eres un asistente experto en multimedia.
Usuario: "{user_message}"
Genera un razonamiento interno con {depth} pasos.
Luego di "Respuesta Final:" con tu respuesta final.
"""
    msgs_for_api = [
        {"role": "system", "content": context},
        {"role": "system", "content": prompt},
        {"role": "user", "content": user_message}
    ]
    
    try:
        # Si tenemos un proveedor inicializado, usarlo
        if current_llm_provider:
            return current_llm_provider.generate_response(
                messages=msgs_for_api,
                model=model,
                temperature=temperature
            )
        # Si no, usar el cliente local por defecto
        else:
            completion = client.chat.completions.create(
                model=model,
                messages=msgs_for_api,
                temperature=temperature
            )
            return completion.choices[0].message.content.strip()
    except Exception as e:
        return f"Error en comunicación con el modelo: {str(e)}"

def strategy_best_of_n(context, user_message, n, model, temperature, full_messages=None):
    return "Not Implemented"

def strategy_weighted_best_of_n(context, user_message, n, model, temperature, full_messages=None):
    return "Not Implemented"

def strategy_beam_search(context, user_message, beam_iterations, model, temperature, full_messages=None):
    return "Not Implemented"

def strategy_dvts(context, user_message, total_subtrees, model, temperature, full_messages=None):
    return "DVTS placeholder"


###############################################################################
#                   PARSEO DE COMANDOS (AMPLIADO CON MULTIMEDIA)
###############################################################################
launcher = None

def get_system_time():
    now = datetime.datetime.now()
    return now.strftime("%Y-%m-%d %H:%M:%S")

def parse_and_execute_command(
    user_text,
    context,
    messages,
    strategy,
    test_time_compute,
    model,
    temperature
):
    lt = user_text.lower()
    
    # Registrar el comando para debugging
    logger.info(f"Analizando comando: {user_text}")

    # Comandos para descargar música/videos - PATRONES MEJORADOS
    download_video_patterns = [
        r"descarga(?:\w)?\s+(?:el\s+)?video\s+de\s+(https?://\S+)",
        r"descarga(?:\w)?\s+(?:el\s+)?video\s+(https?://\S+)",
        r"baja(?:\w)?\s+(?:el\s+)?video\s+de\s+(https?://\S+)",
        r"baja(?:\w)?\s+(?:el\s+)?video\s+(https?://\S+)",
        r"(?:quiero|necesito)\s+(?:descargar|bajar)\s+(?:el\s+)?video\s+(?:de\s+)?(https?://\S+)"
    ]
    
    download_audio_patterns = [
        r"descarga(?:\w)?\s+(?:el\s+)?audio\s+de\s+(https?://\S+)",
        r"descarga(?:\w)?\s+(?:la\s+)?música\s+de\s+(https?://\S+)",
        r"descarga(?:\w)?\s+(?:la\s+)?canción\s+de\s+(https?://\S+)",
        r"baja(?:\w)?\s+(?:el\s+)?audio\s+de\s+(https?://\S+)",
        r"baja(?:\w)?\s+(?:la\s+)?música\s+de\s+(https?://\S+)",
        r"baja(?:\w)?\s+(?:la\s+)?canción\s+de\s+(https?://\S+)",
        r"(?:quiero|necesito)\s+(?:descargar|bajar)\s+(?:el\s+audio|la\s+música|la\s+canción)\s+(?:de\s+)?(https?://\S+)"
    ]
    
    # Verificar patrones de descarga de video
    for pattern in download_video_patterns:
        match = re.search(pattern, user_text, re.IGNORECASE)  # Usar el texto original con case insensitive
        if match:
            url_part = match.group(1)
            # Extraer la URL completa, incluyendo parámetros
            url_match = re.search(r'(https?://\S+)', url_part)
            if url_match:
                url = url_match.group(1)
                logger.info(f"URL de video detectada: {url}")
                print(f"\n[COMANDO] Descargando video: {url}")
                success, message = direct_download_media(url, False, "mp4")
                return True, message
    
    # Verificar patrones de descarga de audio
    for pattern in download_audio_patterns:
        match = re.search(pattern, user_text, re.IGNORECASE)  # Usar el texto original con case insensitive
        if match:
            url_part = match.group(1)
            # Extraer la URL completa, incluyendo parámetros
            url_match = re.search(r'(https?://\S+)', url_part)
            if url_match:
                url = url_match.group(1)
                logger.info(f"URL de audio detectada: {url}")
                print(f"\n[COMANDO] Descargando audio: {url}")
                success, message = direct_download_media(url, True, "mp3")
                return True, message
    
    # Si llegamos hasta aquí, la URL podría estar sin "https://" al principio
    youtube_url_patterns = [
        r"descarga(?:\w)?\s+(?:el\s+)?video\s+(?:de\s+)?(youtu\.be\/\S+)",
        r"descarga(?:\w)?\s+(?:el\s+)?video\s+(?:de\s+)?(youtube\.com\/\S+)",
        r"descarga(?:\w)?\s+(?:la\s+)?música\s+(?:de\s+)?(youtu\.be\/\S+)",
        r"descarga(?:\w)?\s+(?:la\s+)?música\s+(?:de\s+)?(youtube\.com\/\S+)"
    ]
    
    for pattern in youtube_url_patterns:
        match = re.search(pattern, user_text, re.IGNORECASE)
        if match:
            partial_url = match.group(1)
            # Añadir el esquema https:// si falta
            if not partial_url.startswith('http'):
                url = f"https://{partial_url}"
            else:
                url = partial_url
                
            logger.info(f"URL de YouTube corregida: {url}")
            print(f"\n[COMANDO] Detectada URL de YouTube sin protocolo: {url}")
            
            # Determinar si es video o audio basado en el texto completo
            is_audio = "música" in lt or "audio" in lt or "canción" in lt
            success, message = direct_download_media(url, is_audio, "mp3" if is_audio else "mp4")
            return True, message
    
    # Reproducir música o video descargados
    play_media_patterns = [
        r"reproducir?\s+(?:el\s+archivo|el\s+video|la\s+música|la\s+canción|el|la)\s+(.+)",
        r"pon(?:er|ga|me)?\s+(?:el\s+archivo|el\s+video|la\s+música|la\s+canción|el|la)\s+(.+)",
        r"escuchar?\s+(?:el\s+archivo|el\s+video|la\s+música|la\s+canción|el|la)\s+(.+)"
    ]
    
    # Detener reproducción
    stop_media_patterns = [
        r"detén la reproducción",
        r"para la reproducción",
        r"detener música",
        r"parar música",
        r"detener video",
        r"parar video",
        r"stop"
    ]
    
    # Verificar patrones de reproducción
    for pattern in play_media_patterns:
        match = re.search(pattern, lt)
        if match:
            filename = match.group(1).strip()
            logger.info(f"Intentando reproducir: {filename}")
            success, message = launcher.play_media(filename)
            return True, message
    
    # Verificar patrones para detener reproducción
    for pattern in stop_media_patterns:
        if re.search(pattern, lt):
            logger.info("Comando para detener reproducción detectado")
            success, message = launcher.stop_media()
            return True, message
    
    # Patrones para generar imágenes
    generate_image_patterns = [
        r"generar?\s+(?:una\s+)?imagen\s+(?:de\s+)?(.+)",
        r"crear?\s+(?:una\s+)?imagen\s+(?:de\s+)?(.+)",
        r"dibujar?\s+(?:una\s+)?imagen\s+(?:de\s+)?(.+)",
    ]
    
    # Verificar patrones para generar imágenes
    for pattern in generate_image_patterns:
        match = re.search(pattern, lt)
        if match:
            prompt = match.group(1).strip()
            logger.info(f"Generando imagen: {prompt}")
            # Extraer parámetros como tamaño si se especifican
            size = "1024x1024"  # valor por defecto
            
            # Verificar si hay dimensiones específicas mencionadas
            size_pattern = r"(?:tamaño|dimensión|resolución)\s+(\d+\s*[x×]\s*\d+)"
            size_match = re.search(size_pattern, lt)
            if size_match:
                size_text = size_match.group(1)
                # Normalizar formato (quitar espacios, usar x estándar)
                clean_size = size_text.replace(" ", "").replace("×", "x")
                # Verificar si es un tamaño válido
                if clean_size in ["256x256", "512x512", "1024x1024", "1024x1792", "1792x1024"]:
                    size = clean_size
            
            success, message = launcher.generate_image(prompt, size=size)
            return True, message

    # Patrones para generar videos
    generate_video_patterns = [
        r"generar?\s+(?:un\s+)?video\s+(?:de\s+)?(.+)",
        r"crear?\s+(?:un\s+)?video\s+(?:de\s+)?(.+)",
    ]
    
    # Verificar patrones para generar videos
    for pattern in generate_video_patterns:
        match = re.search(pattern, lt)
        if match:
            prompt = match.group(1).strip()
            logger.info(f"Generando video: {prompt}")
            
            # Extraer duración si se especifica
            duration = 5  # valor por defecto
            
            # Buscar mención de duración
            duration_pattern = r"(?:duración|durante)\s+(\d+)\s+(?:segundo|segundos|seg|s)"
            duration_match = re.search(duration_pattern, lt)
            if duration_match:
                try:
                    duration = int(duration_match.group(1))
                    # Limitar duración entre 1 y 60 segundos
                    duration = max(1, min(60, duration))
                except:
                    pass
            
            success, message = launcher.generate_video(prompt, duration=duration)
            return True, message

    # Manejo de "abre spotify" (chrome/firefox) => open "https://open.spotify.com/"
    if "abre spotify" in lt:
        if "chrome" in lt:
            if not launcher.chrome_driver:
                launcher.abrir_chrome_fake("spotify")
                return True, "Abriendo Chrome y Spotify"
            else:
                launcher.update_browsers('chrome', "spotify", "Todo")
                return True, "Spotify en Chrome"
        elif "firefox" in lt:
            if not launcher.firefox_driver:
                launcher.abrir_firefox_fake("spotify")
                return True, "Abriendo Firefox y Spotify"
            else:
                launcher.update_browsers('firefox', "spotify", "Todo")
                return True, "Spotify en Firefox"
        else:
            # default
            if not launcher.chrome_driver:
                launcher.abrir_chrome_fake("spotify")
                return True, "Abriendo Chrome y Spotify"
            else:
                launcher.update_browsers('chrome', "spotify", "Todo")
                return True, "Spotify en Chrome"

    if "abre la red social" in lt and ("usuario" in lt or "contraseña" in lt):
        return True, "Placeholder: abriendo red social"

    # Hora/fecha
    if "qué hora" in lt or "que hora" in lt:
        return True, f"La hora local es: {get_system_time()}"
    if "qué fecha" in lt or "que fecha" in lt:
        return True, f"La fecha/hora local es: {get_system_time()}"

    # Notepad synonyms
    synonyms_notepad = ["notepad", "bloc de notas", "block de notas"]
    if ("abre" in lt and any(syn in lt for syn in synonyms_notepad) and "escribe" in lt):
        ans = handle_app_llm(user_text, context, messages, strategy, test_time_compute, model, temperature, "notepad")
        return True, ans

    # Word
    if "abre" in lt and "word" in lt and "escribe" in lt:
        ans = handle_app_llm(user_text, context, messages, strategy, test_time_compute, model, temperature, "word")
        return True, ans

    # Excel
    if "abre" in lt and "excel" in lt and "escribe" in lt:
        ans = handle_app_llm(user_text, context, messages, strategy, test_time_compute, model, temperature, "excel")
        return True, ans

    # busqueda en chrome/firefox
    if "busca" in lt:
        browser = None
        if "chrome" in lt:
            browser = "chrome"
        elif "firefox" in lt:
            browser = "firefox"

        parted = lt.split("busca", maxsplit=1)
        raw_search = parted[1].strip() if len(parted) > 1 else "búsqueda"

        if browser == "chrome":
            if not launcher.chrome_driver:
                launcher.abrir_chrome_fake(raw_search)
                return True, f"**Abriendo Chrome** y buscando: {raw_search}"
            else:
                launcher.update_browsers('chrome', raw_search, "Todo")
                return True, f"**Usando Chrome abierto** para buscar: {raw_search}"
        elif browser == "firefox":
            if not launcher.firefox_driver:
                launcher.abrir_firefox_fake(raw_search)
                return True, f"**Abriendo Firefox** y buscando: {raw_search}"
            else:
                launcher.update_browsers('firefox', raw_search, "Todo")
                return True, f"**Usando Firefox abierto** para buscar: {raw_search}"

    # Si llegamos aquí, no se encontró un comando válido
    logger.info("No se encontró un comando válido para ejecutar")
    return False, ""

def handle_app_llm(user_text, context, messages, strategy, test_time_compute, model, temperature, app):
    parted = user_text.split("escribe", maxsplit=1)
    user_msg = parted[1].strip() if len(parted) > 1 else "Texto de ejemplo..."

    conv_hist = build_conversation_history(messages)
    ext_ctx = f"{context}\n\nHistorial:\n{conv_hist}"

    if strategy == "Simple":
        raw_resp = strategy_simple(
            context=ext_ctx,
            user_message=user_msg,
            depth=test_time_compute,
            model=model,
            temperature=temperature,
            full_messages=messages
        )
    elif strategy == "DVTS":
        raw_resp = strategy_dvts(
            context=ext_ctx,
            user_message=user_msg,
            total_subtrees=test_time_compute,
            model=model,
            temperature=temperature,
            full_messages=messages
        )
    else:
        raw_resp = "Strategy placeholder..."

    final_resp = raw_resp.replace("Respuesta Final:", "").strip()

    if app == "word":
        clear_win32com_cache()  # Limpiar caché antes de usar Word
        launcher.abrir_word_con_historia(final_resp)
        return f"**He escrito en Word**:\n{final_resp}"
    elif app == "excel":
        clear_win32com_cache()  # Limpiar caché antes de usar Excel
        launcher.write_in_excel(final_resp)
        return f"**He escrito en Excel**:\n{final_resp}"
    elif app == "notepad":
        with tempfile.NamedTemporaryFile(delete=False, suffix=".txt", mode='w', encoding='utf-8') as tmp:
            tmp.write(final_resp)
            path = tmp.name
        subprocess.Popen(['notepad.exe', path])

        # Autoguardado Notepad
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        default_notepad_path = os.path.join(os.getcwd(), f"auto_saved_notepad_{ts}.txt")
        try:
            with open(path, 'r', encoding='utf-8') as src:
                data = src.read()
            with open(default_notepad_path, 'w', encoding='utf-8') as dst:
                dst.write(data)
            logger.warning(f"[Auto-Saved Notepad] => {default_notepad_path}")
        except Exception as e:
            logger.warning(f"Error auto-saving notepad: {e}")

        return f"**He escrito en Notepad**:\n{final_resp}"

    return f"Acción en {app.upper()}: {final_resp}"


###############################################################################
#                          send_message
###############################################################################
def run_all():
    global launcher, current_llm_provider
    logger.info("Iniciando TRON ARES")
    
    # Mensaje de inicio en la consola
    print("=" * 80)
    print("        TRON ARES v2.0 by Viaja Tech")
    print("=" * 80)
    print(" - Soporte para descargas de videos y música de YouTube y otras plataformas")
    print(" - Reproductor multimedia integrado")
    print(" - Integración con aplicaciones Office y navegadores")
    print(" - Soporte para modelos de IA: OpenAI GPT-4o/4.5, Anthropic Claude, Google Gemini 2.5")
    print(" - Generación de imágenes con DALL-E y otros modelos")
    print(" - Simulación de generación de videos con Sora (próximamente API real)")
    print("=" * 80)
    
    # Limpiamos la caché al inicio para evitar problemas
    clear_win32com_cache()
    
    root_tk = tk.Tk()
    launcher = MultiAppLauncher(root_tk)

    with gr.Blocks(title="TRON ARES v2.0 by Viaja Tech") as demo:
        gr.Markdown("# TRON ARES v2.0 by Viaja Tech")
        
        with gr.Accordion("Ayuda y Comandos", open=False):
            gr.Markdown("""
            ## Comandos Disponibles
            
            ### Descargar Multimedia
            - "Descarga el video de [URL]" - Descarga video de YouTube o plataformas compatibles
            - "Descarga la música de [URL]" - Descarga audio de YouTube o plataformas compatibles
            
            ### Reproducción
            - "Reproduce [nombre del archivo]" - Reproduce un archivo de la biblioteca
            - "Detén la reproducción" - Detiene la reproducción actual
            
            ### Generación de Contenido con IA
            - "Genera una imagen de [descripción]" - Crea una imagen con IA
            - "Genera un video de [descripción]" - Simula/crea un video con IA
            
            ### Navegadores
            - "Busca en Chrome/Firefox [término]" - Realiza búsquedas
            - "Abre Spotify" - Abre Spotify en el navegador
            
            ### Aplicaciones Office
            - "Abre Word y escribe [texto]" - Abre Word y escribe el texto generado
            - "Abre Excel y escribe [contenido]" - Abre Excel con el contenido en columnas
            - "Abre Notepad y escribe [texto]" - Abre Notepad con el texto generado
            """)

        with gr.Tab("Configuración"):
            with gr.Row():
                with gr.Column():
                    context_in = gr.Textbox(
                        label="Contexto inicial",
                        lines=3,
                        value="Eres un potente asistente multimedia. Eres extremadamente capaz para ayudar con la descarga y reproducción de música y videos de YouTube y otras plataformas. También puedes generar imágenes y videos con IA, abrir aplicaciones, realizar búsquedas en internet y mucho más."
                    )
                    user_in = gr.Textbox(label="Tu nombre", value="Usuario")
                    bot_in = gr.Textbox(label="Nombre del Chatbot", value="ARES")

                    with gr.Accordion("Configuración de Modelos de IA", open=True):
                        provider_in = gr.Radio(
                            label="Proveedor de LLM",
                            choices=["lm-studio", "anthropic", "openai", "gemini"],
                            value="lm-studio"
                        )
                        
                        api_key_in = gr.Textbox(
                            label="API Key (requerida para Anthropic, OpenAI y Gemini)",
                            type="password",
                            value=""
                        )
                        
                        base_url_in = gr.Textbox(
                            label="URL Base (solo para LM Studio)",
                            value="http://localhost:1234/v1",
                            visible=True
                        )
                        
                        model_dropdown = gr.Dropdown(
                            label="Modelo",
                            choices=["meta-llama-3.1-8b-instruct"],
                            value="meta-llama-3.1-8b-instruct",
                            allow_custom_value=True
                        )
                        
                        with gr.Row():
                            temperature_in = gr.Slider(
                                label="Temperatura",
                                minimum=0.0,
                                maximum=1.0,
                                value=0.7,
                                step=0.1
                            )
                            
                            max_tokens_in = gr.Slider(
                                label="Máximo de tokens",
                                minimum=100,
                                maximum=32000,
                                value=4096,
                                step=100
                            )
                        
                        # Opciones específicas para Anthropic Thinking
                        thinking_checkbox = gr.Checkbox(
                            label="Usar modo Thinking (solo para Claude 3.7)",
                            value=False,
                            visible=False
                        )
                        
                        budget_tokens_in = gr.Slider(
                            label="Budget tokens (para modelos thinking de Anthropic)",
                            minimum=100,
                            maximum=5000,
                            value=1000,
                            step=100,
                            visible=False
                        )

                with gr.Column():
                    use_voice_in = gr.Checkbox(label="Activar salida de voz", value=False)
                    voice_gender_in = gr.Radio(
                        label="Voz del chatbot",
                        choices=["Femenina", "Masculina"],
                        value="Femenina"
                    )

                    strategy_in = gr.Radio(
                        label="Estrategia Test-time Compute",
                        choices=["Simple", "Best-of-N", "Weighted Best-of-N", "Beam Search", "DVTS"],
                        value="Simple"
                    )
                    test_time_in = gr.Number(
                        label="Test-time Compute (1..1000)",
                        value=1,
                        precision=0
                    )
                    
                    # Opciones para multimodal
                    with gr.Accordion("Opciones Multimodales", open=True):
                        gr.Markdown("Subir una imagen para interactuar con ella (para proveedores que soporten visión)")
                        image_upload = gr.Image(type="pil", label="Imagen (opcional)")

            start_button = gr.Button("Iniciar Chatbot", variant="primary")

        with gr.Tab("Chat"):
            chat_history = gr.Chatbot(type="messages")
            with gr.Row():
                message_input = gr.Textbox(label="Escribe tu mensaje...")
                send_button = gr.Button("Enviar", interactive=False)
            voice_input_button = gr.Button("Hablar")
            clear_button = gr.Button("Borrar historial")

        # Función para actualizar la lista de modelos disponibles
        def update_model_choices(provider):
            # Obtener instancia del proveedor para consultar sus modelos
            temp_provider = get_llm_provider(provider)
            models = temp_provider.get_available_models()
            
            # Configurar visibilidad de campos
            show_base_url = (provider == "lm-studio")
            show_thinking = (provider == "anthropic" and any("3-7" in m for m in models))
            
            # Al actualizar un Dropdown en Gradio, debemos devolver un diccionario
            # con las opciones y el valor predeterminado
            return gr.update(
                choices=models,
                value=models[0] if models else None
            ), gr.update(visible=show_base_url), gr.update(visible=show_thinking), gr.update(visible=show_thinking)
        
        # Actualizar opciones de modelos cuando cambia el proveedor
        provider_in.change(
            update_model_choices,
            inputs=[provider_in],
            outputs=[model_dropdown, base_url_in, thinking_checkbox, budget_tokens_in]
        )
        
        # Función para mostrar/ocultar budget tokens según el modelo seleccionado y thinking activado
        def toggle_thinking_budget(provider, model, use_thinking):
            show_budget = (provider == "anthropic" and use_thinking and "3-7" in model)
            return gr.update(visible=show_budget)
            
        # Actualizar visibilidad de budget tokens cuando cambia thinking
        thinking_checkbox.change(
            toggle_thinking_budget,
            inputs=[provider_in, model_dropdown, thinking_checkbox],
            outputs=[budget_tokens_in]
        )

        # States para guardar datos entre interacciones
        st_messages = gr.State()
        st_context = gr.State()
        st_user = gr.State()
        st_bot = gr.State()
        st_provider = gr.State()
        st_api_key = gr.State()
        st_base_url = gr.State()
        st_model = gr.State()
        st_temperature = gr.State()
        st_max_tokens = gr.State()
        st_thinking = gr.State()
        st_budget_tokens = gr.State()
        st_voice_gender = gr.State()
        st_strategy = gr.State()
        st_test_time = gr.State()
        st_image = gr.State()

        def on_start_btn(cx, us, bo, prov, api_key, base_url, mdl, tmp, max_tok, use_thinking, budget_tok, vg, stg, tti, img=None):
            global current_llm_provider
            
            # Validar y ajustar inputs
            if not isinstance(tti, int):
                tti = int(tti)
            if tti < 1:
                tti = 1
            if tti > 1000:
                tti = 1000
                
            # Inicializar el proveedor de LLM
            llm_provider = get_llm_provider(prov, api_key, base_url)
            initialize_success = llm_provider.initialize()
            
            if not initialize_success:
                error_msg = f"Error: No se pudo inicializar el proveedor {prov}. "
                if prov != "lm-studio":
                    error_msg += "Verifica tu API key."
                else:
                    error_msg += "Verifica que LM Studio esté ejecutándose."
                    
                return ([{"role": "assistant", "content": error_msg}], 
                        None, cx, us, bo, prov, api_key, base_url, mdl, tmp, max_tok, use_thinking, budget_tok, vg, stg, tti, None,
                        gr.update(interactive=False))
            
            # Guardar el proveedor en la variable global
            current_llm_provider = llm_provider
            
            # Mensaje inicial del chatbot
            initial_message = f"¡Hola {us}! Soy {bo}. Estoy conectado a {prov.upper()} usando el modelo {mdl}. ¿En qué puedo ayudarte hoy?"
            
            msgs = [
                {"role": "system", "content": cx},
                {"role": "assistant", "content": initial_message}
            ]
            ch = [{"role": "assistant", "content": f"{bo}: {initial_message}"}]
            
            # Procesar imagen si fue proporcionada
            image_data = None
            if img is not None:
                if img:
                    try:
                        # Convertir imagen a formato base64 para APIs
                        buffered = BytesIO()
                        img.save(buffered, format="JPEG")
                        image_b64 = base64.b64encode(buffered.getvalue()).decode('utf-8')
                        image_data = f"data:image/jpeg;base64,{image_b64}"
                        
                        # Añadir mensaje indicando que hay una imagen
                        addon_message = "He cargado una imagen para interactuar con ella. Puedes hacerme preguntas sobre lo que ves."
                        ch.append({"role": "user", "content": f"{us}: {addon_message}"})
                        
                        # Para los mensajes de API, usar formato multimodal adecuado
                        msgs.append({
                            "role": "user", 
                            "content": [
                                {"type": "text", "text": addon_message},
                                {"type": "image_url", "image_url": {"url": image_data}}
                            ]
                        })
                        
                        # Respuesta de confirmación
                        image_response = f"Veo la imagen que has subido. Puedo analizarla y responder preguntas sobre ella. ¿Qué te gustaría saber?"
                        msgs.append({"role": "assistant", "content": image_response})
                        ch.append({"role": "assistant", "content": f"{bo}: {image_response}"})
                    except Exception as img_e:
                        error_img = f"Error al procesar la imagen: {str(img_e)}"
                        logger.error(error_img)
            
            return (ch, msgs, cx, us, bo, prov, api_key, base_url, mdl, tmp, max_tok, use_thinking, budget_tok, vg, stg, tti, image_data,
                    gr.update(interactive=True))

        start_button.click(
            on_start_btn,
            inputs=[
                context_in,
                user_in,
                bot_in,
                provider_in,
                api_key_in,
                base_url_in,
                model_dropdown,
                temperature_in,
                max_tokens_in,
                thinking_checkbox,
                budget_tokens_in,
                voice_gender_in,
                strategy_in,
                test_time_in,
                image_upload
            ],
            outputs=[
                chat_history,
                st_messages,
                st_context,
                st_user,
                st_bot,
                st_provider,
                st_api_key,
                st_base_url,
                st_model,
                st_temperature,
                st_max_tokens,
                st_thinking,
                st_budget_tokens,
                st_voice_gender,
                st_strategy,
                st_test_time,
                st_image,
                send_button
            ]
        )

        def on_send(u_msg, ch, ms, cx, ur, bo, prov, api_key, base_url, mdl, tmp, max_tok, use_thinking, budget_tok, uv, vg, stg, tti, img_data):
            if not isinstance(tti, int):
                tti = int(tti)
            if tti < 1:
                tti = 1
            if tti > 1000:
                tti = 1000
                
            # Verificar si tenemos mensajes
            if ms is None:
                return "", ch, ms

            # Intenta ejecutar un comando (descarga, reproducción, etc)
            executed, result = parse_and_execute_command(
                user_text=u_msg,
                context=cx,
                messages=ms,
                strategy=stg,
                test_time_compute=tti,
                model=mdl,
                temperature=tmp
            )
            
            # Si se ejecutó un comando, registra y responde
            if executed:
                logger.info(f"Comando ejecutado: '{u_msg}' con resultado: {result}")
                
                ms.append({"role": "user", "content": u_msg})
                ms.append({"role": "assistant", "content": result})

                ch.append({"role": "user", "content": f"{ur}: {u_msg}"})
                ch.append({"role": "assistant", "content": f"{bo}: {result}"})
                return "", ch, ms

            # Si no se ejecutó ningún comando, usa el modelo para generar una respuesta
            logger.info(f"No se ejecutó comando, enviando a modelo: '{u_msg}'")
            
            # Verificar que tenemos un proveedor inicializado
            global current_llm_provider
            if current_llm_provider is None:
                # Intentamos inicializarlo
                current_llm_provider = get_llm_provider(prov, api_key, base_url)
                if not current_llm_provider.initialize():
                    result = f"Error: No se pudo inicializar el proveedor {prov}. Verifica la configuración."
                    ms.append({"role": "user", "content": u_msg})
                    ms.append({"role": "assistant", "content": result})
                    ch.append({"role": "user", "content": f"{ur}: {u_msg}"})
                    ch.append({"role": "assistant", "content": f"{bo}: {result}"})
                    return "", ch, ms
            
            # Preparar mensajes para el modelo (mantener contexto pero quitar nombres)
            model_messages = []
            for m in ms:
                content = m["content"]
                role = m["role"]
                
                # Si el contenido tiene formato "Nombre: mensaje", extraer solo el mensaje
                if isinstance(content, str) and ":" in content and role in ["user", "assistant"]:
                    parts = content.split(":", 1)
                    if len(parts) == 2:
                        content = parts[1].strip()
                
                # Procesar contenido multimedia si existe
                if isinstance(content, list):
                    model_messages.append({"role": role, "content": content})
                else:
                    model_messages.append({"role": role, "content": content})
            
            # Agregar el mensaje actual del usuario
            # Si hay una imagen en sesión y es el primer mensaje, podríamos añadirla al mensaje
            if img_data and len(model_messages) <= 3:  # Mensaje inicial + imagen
                user_content = [
                    {"type": "text", "text": u_msg},
                    {"type": "image_url", "image_url": {"url": img_data}}
                ]
                model_messages.append({"role": "user", "content": user_content})
            else:
                model_messages.append({"role": "user", "content": u_msg})
            
            # Parámetros adicionales específicos del proveedor
            kwargs = {}
            if prov == "anthropic" and use_thinking:
                kwargs["thinking"] = True
                kwargs["thinking_budget"] = budget_tok if budget_tok else 1000
            
            # Generar respuesta
            resp = current_llm_provider.generate_response(
                messages=model_messages,
                model=mdl,
                temperature=tmp,
                max_tokens=max_tok,
                **kwargs
            )
            
            # Actualizar historiales
            # Para el historial de mensajes de API, guardar en formato correcto
            if img_data and len(model_messages) <= 4:  # Es un mensaje con imagen
                ms.append({
                    "role": "user", 
                    "content": [
                        {"type": "text", "text": u_msg},
                        {"type": "image_url", "image_url": {"url": img_data}}
                    ]
                })
            else:
                ms.append({"role": "user", "content": u_msg})
                
            ms.append({"role": "assistant", "content": resp})

            # Para la interfaz de chat, mostrar en formato legible
            ch.append({"role": "user", "content": f"{ur}: {u_msg}"})
            ch.append({"role": "assistant", "content": f"{bo}: {resp}"})

            # Si está activada la voz, convertir texto a voz
            if uv:
                threading.Thread(
                    target=speak_text_azure,
                    args=(resp, vg),
                    daemon=True
                ).start()

            return "", ch, ms

        send_button.click(
            on_send,
            inputs=[
                message_input,
                chat_history,
                st_messages,
                st_context,
                st_user,
                st_bot,
                st_provider,
                st_api_key,
                st_base_url,
                st_model,
                st_temperature,
                st_max_tokens,
                st_thinking,
                st_budget_tokens,
                use_voice_in,
                st_voice_gender,
                st_strategy,
                st_test_time,
                st_image
            ],
            outputs=[message_input, chat_history, st_messages]
        )

        message_input.submit(
            on_send,
            inputs=[
                message_input,
                chat_history,
                st_messages,
                st_context,
                st_user,
                st_bot,
                st_provider,
                st_api_key,
                st_base_url,
                st_model,
                st_temperature, 
                st_max_tokens,
                st_thinking,
                st_budget_tokens,
                use_voice_in,
                st_voice_gender,
                st_strategy,
                st_test_time,
                st_image
            ],
            outputs=[message_input, chat_history, st_messages]
        )

        voice_input_button.click(
            transcribe_audio,
            inputs=None,
            outputs=message_input
        )

        def on_clear():
            global current_llm_provider
            current_llm_provider = None
            
            return [], [], "", "", "", "lm-studio", "", "http://localhost:1234/v1", "", 0.7, 4096, False, 1000, "Femenina", "Simple", 1, None, gr.update(interactive=False)

        clear_button.click(
            on_clear,
            outputs=[
                chat_history,
                st_messages,
                st_context,
                st_user,
                st_bot,
                st_provider,
                st_api_key,
                st_base_url,
                st_model,
                st_temperature, 
                st_max_tokens,
                st_thinking,
                st_budget_tokens,
                st_voice_gender,
                st_strategy,
                st_test_time,
                st_image,
                send_button
            ]
        )

        demo.launch(share=False)

    t = threading.Thread(target=launcher.main, daemon=True)
    t.start()


if __name__ == "__main__":
    run_all()
